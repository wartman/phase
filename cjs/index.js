// Generated by Haxe 4.2.1+bf9ff69
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileInput
});
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.prototype = {
	__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.withExtension = function(path,ext) {
	var s = new haxe_io_Path(path);
	s.ext = ext;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_node_Fs = require("fs");
var js_node_KeyValue = {};
js_node_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_node_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_stream_WritableNewOptionsAdapter = {};
js_node_stream_WritableNewOptionsAdapter.from = function(options) {
	if(!Object.prototype.hasOwnProperty.call(options,"final")) {
		Object.defineProperty(options,"final",{ get : function() {
			return options.final_;
		}});
	}
	return options;
};
var js_node_url_URLSearchParamsEntry = {};
js_node_url_URLSearchParamsEntry._new = function(name,value) {
	var this1 = [name,value];
	return this1;
};
js_node_url_URLSearchParamsEntry.get_name = function(this1) {
	return this1[0];
};
js_node_url_URLSearchParamsEntry.get_value = function(this1) {
	return this1[1];
};
var phase_Attribute = function(path,params,relative,expr) {
	this.path = path;
	this.params = params;
	this.relative = relative;
	this.expr = expr;
};
phase_Attribute.__name__ = true;
phase_Attribute.prototype = {
	accept: function(visitor) {
		return visitor.visitAttributeExpr(this);
	}
	,__class__: phase_Attribute
};
var phase_Assign = function(name,value) {
	this.name = name;
	this.value = value;
};
phase_Assign.__name__ = true;
phase_Assign.prototype = {
	accept: function(visitor) {
		return visitor.visitAssignExpr(this);
	}
	,__class__: phase_Assign
};
var phase_Binary = function(left,op,right) {
	this.left = left;
	this.op = op;
	this.right = right;
};
phase_Binary.__name__ = true;
phase_Binary.prototype = {
	accept: function(visitor) {
		return visitor.visitBinaryExpr(this);
	}
	,__class__: phase_Binary
};
var phase_Unary = function(op,expr,right) {
	this.op = op;
	this.expr = expr;
	this.right = right;
};
phase_Unary.__name__ = true;
phase_Unary.prototype = {
	accept: function(visitor) {
		return visitor.visitUnaryExpr(this);
	}
	,__class__: phase_Unary
};
var phase_Is = function(left,type) {
	this.left = left;
	this.type = type;
};
phase_Is.__name__ = true;
phase_Is.prototype = {
	accept: function(visitor) {
		return visitor.visitIsExpr(this);
	}
	,__class__: phase_Is
};
var phase_Logical = function(left,op,right) {
	this.left = left;
	this.op = op;
	this.right = right;
};
phase_Logical.__name__ = true;
phase_Logical.prototype = {
	accept: function(visitor) {
		return visitor.visitLogicalExpr(this);
	}
	,__class__: phase_Logical
};
var phase_Range = function(from,to) {
	this.from = from;
	this.to = to;
};
phase_Range.__name__ = true;
phase_Range.prototype = {
	accept: function(visitor) {
		return visitor.visitRangeExpr(this);
	}
	,__class__: phase_Range
};
var phase_CallArgument = $hxEnums["phase.CallArgument"] = { __ename__:true,__constructs__:null
	,Positional: ($_=function(expr) { return {_hx_index:0,expr:expr,__enum__:"phase.CallArgument",toString:$estr}; },$_._hx_name="Positional",$_.__params__ = ["expr"],$_)
	,Named: ($_=function(name,expr) { return {_hx_index:1,name:name,expr:expr,__enum__:"phase.CallArgument",toString:$estr}; },$_._hx_name="Named",$_.__params__ = ["name","expr"],$_)
};
phase_CallArgument.__constructs__ = [phase_CallArgument.Positional,phase_CallArgument.Named];
var phase_Call = function(callee,paren,args) {
	this.callee = callee;
	this.paren = paren;
	this.args = args;
};
phase_Call.__name__ = true;
phase_Call.prototype = {
	accept: function(visitor) {
		return visitor.visitCallExpr(this);
	}
	,__class__: phase_Call
};
var phase_Get = function(object,name) {
	this.object = object;
	this.name = name;
};
phase_Get.__name__ = true;
phase_Get.prototype = {
	accept: function(visitor) {
		return visitor.visitGetExpr(this);
	}
	,__class__: phase_Get
};
var phase_Set = function(object,name,value) {
	this.object = object;
	this.name = name;
	this.value = value;
};
phase_Set.__name__ = true;
phase_Set.prototype = {
	accept: function(visitor) {
		return visitor.visitSetExpr(this);
	}
	,__class__: phase_Set
};
var phase_SubscriptGet = function(end,object,index) {
	this.end = end;
	this.object = object;
	this.index = index;
};
phase_SubscriptGet.__name__ = true;
phase_SubscriptGet.prototype = {
	accept: function(visitor) {
		return visitor.visitSubscriptGetExpr(this);
	}
	,__class__: phase_SubscriptGet
};
var phase_SubscriptSet = function(end,object,index,value) {
	this.end = end;
	this.object = object;
	this.index = index;
	this.value = value;
};
phase_SubscriptSet.__name__ = true;
phase_SubscriptSet.prototype = {
	accept: function(visitor) {
		return visitor.visitSubscriptSetExpr(this);
	}
	,__class__: phase_SubscriptSet
};
var phase_Ternary = function(condition,thenBranch,elseBranch) {
	this.condition = condition;
	this.thenBranch = thenBranch;
	this.elseBranch = elseBranch;
};
phase_Ternary.__name__ = true;
phase_Ternary.prototype = {
	accept: function(visitor) {
		return visitor.visitTernaryExpr(this);
	}
	,__class__: phase_Ternary
};
var phase_Super = function(keyword,method) {
	this.keyword = keyword;
	this.method = method;
};
phase_Super.__name__ = true;
phase_Super.prototype = {
	accept: function(visitor) {
		return visitor.visitSuperExpr(this);
	}
	,__class__: phase_Super
};
var phase_This = function(keyword) {
	this.keyword = keyword;
};
phase_This.__name__ = true;
phase_This.prototype = {
	accept: function(visitor) {
		return visitor.visitThisExpr(this);
	}
	,__class__: phase_This
};
var phase_Static = function(keyword) {
	this.keyword = keyword;
};
phase_Static.__name__ = true;
phase_Static.prototype = {
	accept: function(visitor) {
		return visitor.visitStaticExpr(this);
	}
	,__class__: phase_Static
};
var phase_Grouping = function(expression) {
	this.expression = expression;
};
phase_Grouping.__name__ = true;
phase_Grouping.prototype = {
	accept: function(visitor) {
		return visitor.visitGroupingExpr(this);
	}
	,__class__: phase_Grouping
};
var phase_Literal = function(value) {
	this.value = value;
};
phase_Literal.__name__ = true;
phase_Literal.prototype = {
	accept: function(visitor) {
		return visitor.visitLiteralExpr(this);
	}
	,__class__: phase_Literal
};
var phase_ArrayLiteral = function(end,values) {
	this.end = end;
	this.values = values;
};
phase_ArrayLiteral.__name__ = true;
phase_ArrayLiteral.prototype = {
	accept: function(visitor) {
		return visitor.visitArrayLiteralExpr(this);
	}
	,__class__: phase_ArrayLiteral
};
var phase_AssocArrayLiteral = function(end,keys,values) {
	this.end = end;
	this.keys = keys;
	this.values = values;
};
phase_AssocArrayLiteral.__name__ = true;
phase_AssocArrayLiteral.prototype = {
	accept: function(visitor) {
		return visitor.visitAssocArrayLiteralExpr(this);
	}
	,__class__: phase_AssocArrayLiteral
};
var phase_Lambda = function(func) {
	this.func = func;
};
phase_Lambda.__name__ = true;
phase_Lambda.prototype = {
	accept: function(visitor) {
		return visitor.visitLambdaExpr(this);
	}
	,__class__: phase_Lambda
};
var phase_Type = function(path,absolute) {
	this.path = path;
	this.absolute = absolute;
};
phase_Type.__name__ = true;
phase_Type.prototype = {
	accept: function(visitor) {
		return visitor.visitTypeExpr(this);
	}
	,__class__: phase_Type
};
var phase_Namespaced = function(type,name) {
	this.type = type;
	this.name = name;
};
phase_Namespaced.__name__ = true;
phase_Namespaced.prototype = {
	accept: function(visitor) {
		return visitor.visitNamespacedExpr(this);
	}
	,__class__: phase_Namespaced
};
var phase_Variable = function(name) {
	this.name = name;
};
phase_Variable.__name__ = true;
phase_Variable.prototype = {
	accept: function(visitor) {
		return visitor.visitVariableExpr(this);
	}
	,__class__: phase_Variable
};
var phase_NodeCompiler = $hx_exports["Compiler"] = function() { };
phase_NodeCompiler.__name__ = true;
phase_NodeCompiler.compile = $hx_exports["compile"] = function(src,options,relative) {
	if(relative == null) {
		relative = haxe_io_Path.normalize(src);
	}
	if(options == null) {
		options = { attribute : "on-class"};
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = js_node_Fs.readdirSync(src);
	while(_g1 < _g2.length) {
		var name = _g2[_g1];
		++_g1;
		var path = haxe_io_Path.join([src,name]);
		if(sys_FileSystem.isDirectory(path)) {
			_g.push(phase_NodeCompiler.compile(path,options,relative));
		} else if(Lambda.has(phase_NodeCompiler.extensions,haxe_io_Path.extension(path))) {
			_g.push(phase_NodeCompiler.compileFile(path,options,relative));
		} else {
			_g.push(Promise.resolve(null));
		}
	}
	return Promise.all(_g).then(function(parts) {
		var _g = [];
		var _g1 = 0;
		var _g2 = parts;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != null) {
				_g.push(v);
			}
		}
		return Lambda.fold(_g,function(value,result) {
			if(((value) instanceof Array)) {
				return result.concat(value);
			}
			result.push(value);
			return result;
		},[]);
	});
};
phase_NodeCompiler.write = $hx_exports["write"] = function(dst,modules) {
	var _g = 0;
	while(_g < modules.length) {
		var m = modules[_g];
		++_g;
		var path = haxe_io_Path.withExtension(haxe_io_Path.join([dst,m.name]),"php");
		var dir = haxe_io_Path.directory(path);
		if(!sys_FileSystem.exists(dir)) {
			sys_FileSystem.createDirectory(dir);
		}
		js_node_Fs.writeFileSync(path,m.generated);
	}
	return Promise.resolve(modules);
};
phase_NodeCompiler.compileFile = function(path,options,relative) {
	var source = phase_NodeCompiler.load(path);
	var reporter = new phase_VisualErrorReporter(source);
	var scanner = new phase_Scanner(source,path,reporter);
	var parser = new phase_Parser(scanner.scan(),reporter);
	var generator = new phase_PhpGenerator(parser.parse(),reporter,options);
	if(reporter.hadError()) {
		return Promise.reject("Parsing failed: " + path);
	}
	return Promise.resolve({ realPath : path, name : haxe_io_Path.withoutExtension(haxe_io_Path.normalize(HxOverrides.substr(path,relative.length + 1,null))), source : source, generated : generator.generate()});
};
phase_NodeCompiler.load = function(path) {
	return js_node_Fs.readFileSync(path,{ encoding : "utf8"});
};
var phase_Parser = function(tokens,reporter) {
	this.inNamespace = false;
	this.uid = 0;
	this.tokens = tokens;
	this.reporter = reporter;
};
phase_Parser.__name__ = true;
phase_Parser.prototype = {
	parse: function() {
		var stmts = [];
		this.current = 0;
		this.ignoreNewlines();
		while(!this.isAtEnd()) {
			var stmt = this.declaration();
			if(stmt != null) {
				stmts.push(stmt);
			}
		}
		return stmts;
	}
	,declaration: function(attribute) {
		if(attribute == null) {
			attribute = [];
		}
		try {
			if(this.match(["["])) {
				return this.declaration(this.attributeList());
			}
			if(this.match(["var"])) {
				if(attribute.length > 0) {
					this.error(this.previous(),"Attributes are not allowed here");
				}
				return this.varDeclaration();
			}
			if(this.match(["global"])) {
				if(attribute.length > 0) {
					this.error(this.previous(),"Attributes are not allowed here");
				}
				return this.globalDeclaration();
			}
			if(this.match(["function"])) {
				return this.functionDeclaration(false,attribute);
			}
			if(this.match(["enum"])) {
				return this.enumDeclaration(attribute);
			}
			if(this.match(["interface"])) {
				return this.interfaceDeclaration(attribute);
			}
			if(this.match(["trait"])) {
				return this.traitDeclaration(attribute);
			}
			if(this.match(["class"])) {
				return this.classDeclaration(attribute);
			}
			if(this.match(["use"])) {
				return this.useDeclaration(attribute);
			}
			if(this.match(["namespace"])) {
				return this.packageDeclaration(attribute);
			}
			return this.statement();
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof phase_ParserError)) {
				this.synchronize();
				return null;
			} else {
				throw _g;
			}
		}
	}
	,statement: function() {
		if(this.match(["if"])) {
			return this.ifStatement();
		}
		if(this.match(["while"])) {
			return this.whileStatement();
		}
		if(this.match(["for"])) {
			return this.forStatement();
		}
		if(this.match(["switch"])) {
			return this.switchStatement();
		}
		if(this.match(["return"])) {
			return this.returnStatement();
		}
		if(this.match(["throw"])) {
			return this.throwStatement();
		}
		if(this.match(["try"])) {
			return this.tryStatement();
		}
		if(this.match(["{"])) {
			return this.blockStatement();
		}
		return this.expressionStatement();
	}
	,packageDeclaration: function(attribute) {
		var _gthis = this;
		if(this.inNamespace) {
			this.error(this.previous(),"Namespaces cannot be nested");
		}
		this.inNamespace = true;
		var path = this.parseList("::",function() {
			return _gthis.consume("[type-identifier]","Expect a package name seperated by '::'");
		});
		this.consume("{","Expect `{` after a package name.");
		this.ignoreNewlines();
		var decls = [];
		while(!this.check("}") && !this.isAtEnd()) decls.push(this.declaration());
		this.consume("}","Expect `}` at the end of a package declaration.");
		this.ignoreNewlines();
		this.inNamespace = false;
		return new phase_Namespace(path,decls,attribute);
	}
	,useDeclaration: function(attribute) {
		var _gthis = this;
		if(!this.inNamespace) {
			this.error(this.previous(),"`use` is not allowed outside a namespace");
		}
		var kind = phase_UseKind.UseNormal;
		var absolute = false;
		var path = [];
		if(this.match(["::"])) {
			absolute = true;
		}
		while(true) {
			this.ignoreNewlines();
			if(this.match(["[type-identifier]"])) {
				path.push(this.previous());
			} else if(this.match(["[identifier]"])) {
				kind = phase_UseKind.UseSub([phase_UseTarget.TargetFunction(this.previous())]);
				if(this.match(["::"])) {
					throw haxe_Exception.thrown(this.error(this.previous(),"Lowercase identifiers may only come at the end of a use statement."));
				}
				break;
			} else if(this.match(["{"])) {
				kind = phase_UseKind.UseSub(this.parseList(",",function() {
					if(_gthis.match(["[type-identifier]","[identifier]"])) {
						var tok = _gthis.previous();
						if(tok.type == "[identifier]") {
							return phase_UseTarget.TargetFunction(tok);
						} else {
							return phase_UseTarget.TargetType(tok);
						}
					} else {
						throw haxe_Exception.thrown(_gthis.error(_gthis.peek(),"Expect an identifier or a type identifier"));
					}
				}));
				this.ignoreNewlines();
				this.consume("}","Expect a '}'.");
				break;
			} else {
				throw haxe_Exception.thrown(this.error(this.previous(),"Expected a type identifier or a '{'"));
			}
			if(!(this.match(["::"]) && !this.isAtEnd())) {
				break;
			}
		}
		if(this.match(["as"])) {
			if(this.match(["[type-identifier]","[identifier]"])) {
				var tok = this.previous();
				if(kind._hx_index == 2) {
					var _g = kind.items;
					if(_g.length == 1) {
						var _g1 = _g[0];
						if(_g1._hx_index == 1) {
							var p = _g1.name;
							path.push(p);
						}
					}
				}
				kind = phase_UseKind.UseAlias(tok.type == "[identifier]" ? phase_UseTarget.TargetFunction(tok) : phase_UseTarget.TargetType(tok));
			} else {
				throw haxe_Exception.thrown(this.error(this.peek(),"Expect an identifier or a type identifier"));
			}
		}
		this.expectEndOfStatement();
		return new phase_Use(path,absolute,kind,attribute);
	}
	,varDeclaration: function() {
		var name = this.consume("[identifier]","Expect variable name.");
		var init = null;
		if(this.match(["="])) {
			init = this.expression();
		}
		this.expectEndOfStatement();
		return new phase_Var(name,init);
	}
	,globalDeclaration: function() {
		var name = this.consume("[identifier]","Expect variable name.");
		this.expectEndOfStatement();
		return new phase_Global(name);
	}
	,functionDef: function(isAnnon,attributes) {
		if(attributes == null) {
			attributes = [];
		}
		var name;
		if(!isAnnon || this.check("[identifier]")) {
			name = this.consume("[identifier]","Expect function name.");
		} else {
			name = new phase_Token("[identifier]","",null,this.previous().pos);
		}
		this.consume("(","Expect '(' after function name.");
		var params = this.functionParams();
		var ret = this.typeHint();
		this.consume("{","Expect '{' before function body");
		var body = this.functionBody();
		return new phase_Function(name,params,body,ret,attributes);
	}
	,functionParams: function(allowInit) {
		if(allowInit == null) {
			allowInit = false;
		}
		var params = [];
		if(!this.check(")")) {
			while(true) {
				this.ignoreNewlines();
				var isInit = false;
				if(allowInit && this.match(["this"])) {
					isInit = true;
					this.consume(".","Expect a '.' after 'this'.");
				}
				var name = this.consume("[identifier]","Expect parameter name");
				var type = this.typeHint();
				var expr = null;
				if(this.match(["="])) {
					expr = this.expression();
				}
				params.push({ name : name, type : type, expr : expr, isInit : isInit});
				if(!this.match([","])) {
					break;
				}
			}
		}
		this.ignoreNewlines();
		this.consume(")","Expect ')' after parameters");
		return params;
	}
	,functionBody: function() {
		var body = null;
		if(this.match(["}"])) {
			return new phase_Block([]);
		}
		if(!this.check("[newline]") && !this.check("return")) {
			body = [new phase_Return(this.peek(),this.expression())];
			this.ignoreNewlines();
			this.consume("}","Inline functions must contain only one expression.");
		} else {
			body = this.block();
		}
		return new phase_Block(body);
	}
	,functionDeclaration: function(isInline,attributes) {
		if(isInline == null) {
			isInline = false;
		}
		var def = this.functionDef(isInline,attributes);
		this.ignoreNewlines();
		return def;
	}
	,interfaceDeclaration: function(attribute) {
		var name = this.consume("[type-identifier]","Expect a class name. Must start uppercase.");
		var interfaces = [];
		var fields = [];
		this.ignoreNewlines();
		while(this.match(["extends"]) && !this.isAtEnd()) {
			interfaces.push(this.consume("[type-identifier]","Expect an interface name"));
			this.ignoreNewlines();
		}
		this.consume("{","Expect '{' before interface body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			fields.push(this.fieldDeclaration({ access : [phase_FieldAccess.AAbstract]}));
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of interface body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindInterface,null,interfaces,fields,attribute);
	}
	,traitDeclaration: function(attribute) {
		var name = this.consume("[type-identifier]","Expect a trait name. Must start uppercase.");
		var fields = [];
		this.consume("{","Expect '{' before trait body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			fields.push(this.fieldDeclaration());
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of trait body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindTrait,null,[],fields,attribute);
	}
	,enumDeclaration: function(attribute) {
		var name = this.consume("[type-identifier]","Expect an enum name. Must start uppercase.");
		var fields = [];
		this.consume("{","Expect '{' before trait body.");
		this.ignoreNewlines();
		var index = 0;
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			var fieldName = this.consume("[type-identifier]","Expect an uppercase identifier");
			var value = this.match(["="]) ? this.expression() : new phase_Literal(index);
			++index;
			this.expectEndOfStatement();
			fields.push(new phase_Field(fieldName,phase_FieldKind.FVar(new phase_Var(fieldName,value),null),[phase_FieldAccess.AConst],[]));
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of trait body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindClass,null,[],fields,attribute);
	}
	,classDeclaration: function(attribute) {
		var name = this.consume("[type-identifier]","Expect a class name. Must start uppercase.");
		var superclass = null;
		var interfaces = [];
		var fields = [];
		this.ignoreNewlines();
		while(this.match(["extends","implements"]) && !this.isAtEnd()) {
			switch(this.previous().type) {
			case "extends":
				if(superclass != null) {
					throw haxe_Exception.thrown(this.error(this.previous(),"Can only extend once"));
				}
				superclass = this.consume("[type-identifier]","Expect a superclass name");
				break;
			case "implements":
				interfaces.push(this.consume("[type-identifier]","Expect an interface name"));
				break;
			default:
			}
			this.ignoreNewlines();
		}
		this.consume("{","Expect '{' before class body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			var field = this.fieldDeclaration();
			fields.push(field);
			var _g = field.kind;
			if(_g._hx_index == 3) {
				var func = _g.fun;
				var _g1 = 0;
				var _g2 = func.params;
				while(_g1 < _g2.length) {
					var a = [_g2[_g1]];
					++_g1;
					if(a[0].isInit == true && !Lambda.exists(fields,(function(a) {
						return function(f) {
							return f.name.lexeme == a[0].name.lexeme;
						};
					})(a))) {
						fields.push(new phase_Field(a[0].name,phase_FieldKind.FVar(new phase_Var(a[0].name,null),a[0].type),[phase_FieldAccess.APublic],[]));
					}
				}
			}
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of class body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindClass,superclass,interfaces,fields,attribute);
	}
	,fieldDeclaration: function(options) {
		var _gthis = this;
		if(options == null) {
			options = { access : []};
		}
		if(this.match(["use"])) {
			var out = new phase_Field(this.previous(),phase_FieldKind.FUse(this.parseTypePath()),[],[]);
			this.expectEndOfStatement();
			return out;
		}
		if(this.match(["const"])) {
			var name = this.consume("[type-identifier]","Expect uppercase identifier");
			this.ignoreNewlines();
			this.consume("=","Expect assignment for consts");
			var value = this.expression();
			var out = new phase_Field(name,phase_FieldKind.FVar(new phase_Var(name,value),null),[phase_FieldAccess.AConst],[]);
			this.expectEndOfStatement();
			return out;
		}
		var access = options.access;
		var attribute = [];
		var addAccess = function(a) {
			if(Lambda.has(access,a)) {
				_gthis.error(_gthis.previous(),"Only one `" + Std.string(a) + "` declaration is allowed per field");
			}
			access.push(a);
		};
		if(this.match(["["])) {
			attribute = this.attributeList();
		}
		while(this.match(["static","public","private","abstract"]) && !this.isAtEnd()) switch(this.previous().type) {
		case "abstract":
			addAccess(phase_FieldAccess.AAbstract);
			break;
		case "private":
			addAccess(phase_FieldAccess.APrivate);
			break;
		case "public":
			addAccess(phase_FieldAccess.APublic);
			break;
		case "static":
			addAccess(phase_FieldAccess.AStatic);
			break;
		default:
		}
		if(access.length == 0 || !Lambda.has(access,phase_FieldAccess.APublic) && !Lambda.has(access,phase_FieldAccess.APrivate)) {
			access.push(phase_FieldAccess.APublic);
		}
		var name = this.consume("[identifier]","Expected an identifier");
		var type = null;
		if(this.match([":"])) {
			type = this.parseTypePath();
		}
		if(this.match(["[newline]"])) {
			this.ignoreNewlines();
			return new phase_Field(name,phase_FieldKind.FVar(new phase_Var(name,null),type),access,attribute);
		}
		if(this.match(["{"])) {
			var getter = null;
			var setter = null;
			while(!this.check("}") && !this.isAtEnd()) {
				this.ignoreNewlines();
				var mode = this.consume("[identifier]","Expected an identifier");
				switch(mode.lexeme) {
				case "get":
					if(getter != null) {
						throw haxe_Exception.thrown(this.error(mode,"`get` already defined"));
					}
					this.consume("{","expected a `{`");
					var body = this.functionBody();
					this.expectEndOfStatement();
					getter = new phase_Function(mode,[],body,type,[]);
					break;
				case "set":
					if(setter != null) {
						throw haxe_Exception.thrown(this.error(mode,"`set` already defined"));
					}
					this.consume("{","expected a `{`");
					var body1 = this.functionBody();
					this.expectEndOfStatement();
					setter = new phase_Function(mode,[{ name : new phase_Token("[identifier]","value","value",this.previous().pos), type : type, expr : null}],body1,type,[]);
					break;
				default:
					throw haxe_Exception.thrown(this.error(mode,"Expected `get` or `set`"));
				}
			}
			this.ignoreNewlines();
			this.consume("}","Expected a `}`");
			return new phase_Field(name,phase_FieldKind.FProp(getter,setter,type),access,attribute);
		}
		if(this.match(["="])) {
			if(Lambda.has(access,phase_FieldAccess.AAbstract)) {
				throw haxe_Exception.thrown(this.error(this.previous(),"No assignment allowed"));
			}
			this.ignoreNewlines();
			var expr = this.expression();
			this.expectEndOfStatement();
			return new phase_Field(name,phase_FieldKind.FVar(new phase_Var(name,expr),type),access,attribute);
		}
		this.consume("(","Expect '(' after function name.");
		var params = this.functionParams(name.lexeme == "new");
		var ret = this.typeHint();
		var body = null;
		if(Lambda.has(access,phase_FieldAccess.AAbstract)) {
			this.expectEndOfStatement();
		} else {
			this.consume("{","Expect '{' before function body");
			body = this.functionBody();
			this.expectEndOfStatement();
		}
		return new phase_Field(name,phase_FieldKind.FFun(new phase_Function(name,params,body,ret,[])),access,attribute);
	}
	,attributeList: function() {
		var _gthis = this;
		var attribute = [];
		while(true) {
			var absolute = false;
			if(this.match(["::"])) {
				absolute = true;
			}
			var path = this.parseList("::",function() {
				return _gthis.consume("[type-identifier]","Expect a package name seperated by '::'");
			});
			var params = [];
			if(this.match(["("])) {
				if(!this.check(")")) {
					params = this.parseArguments();
				}
				this.ignoreNewlines();
				this.consume(")","Expect ')' at the end of an attribute");
			}
			this.ignoreNewlines();
			attribute.push(new phase_Attribute(path,params,absolute,null));
			if(!this.match([","])) {
				break;
			}
		}
		this.consume("]","Expect a ']' at the end of an attribute");
		this.ignoreNewlines();
		if(this.match(["["])) {
			attribute = attribute.concat(this.attributeList());
		}
		return attribute;
	}
	,throwStatement: function() {
		var value = this.expression();
		this.expectEndOfStatement();
		return new phase_Throw(this.previous(),value);
	}
	,tryStatement: function() {
		this.ignoreNewlines();
		this.consume("{","Expect '{' after 'try'");
		this.ignoreNewlines();
		var body = this.blockStatement();
		var caught = [];
		this.ignoreNewlines();
		while(this.match(["catch"]) && !this.isAtEnd()) {
			this.consume("(","Expect '('");
			var name = this.consume("[identifier]","Expect an identifier");
			var type = this.typeHint();
			this.consume(")","Expect ')'");
			this.consume("{","Expect '{'");
			this.ignoreNewlines();
			var body1 = this.blockStatement();
			caught.push({ name : name, type : type, body : body1});
		}
		return new phase_Try(body,caught);
	}
	,ifStatement: function() {
		this.consume("(","Expect '(' after 'if'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after if condition.");
		var thenBranch = this.statement();
		if(!((thenBranch) instanceof phase_Block)) {
			thenBranch = new phase_Block([thenBranch]);
		}
		var elseBranch = null;
		if(this.match(["else"])) {
			elseBranch = this.statement();
			if(!((elseBranch) instanceof phase_Block)) {
				elseBranch = new phase_Block([elseBranch]);
			}
		}
		return new phase_If(condition,thenBranch,elseBranch);
	}
	,whileStatement: function() {
		this.consume("(","Expect '(' after 'while'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after 'while' condition.");
		var body = this.statement();
		return new phase_While(condition,body);
	}
	,forStatement: function() {
		this.consume("(","Expect '(' after 'for'.");
		var key = this.consume("[identifier]","Expect an identifier");
		var value = null;
		if(this.check(":")) {
			this.advance();
			value = this.consume("[identifier]","Expect an identifier after a colon");
		}
		this.consume("in","Expect `in` after destructuring");
		var target = this.expression();
		this.consume(")","Expect ')'");
		var body = this.statement();
		return new phase_For(key,value,target,body);
	}
	,switchStatement: function() {
		this.consume("(","Expect '(' after 'switch'.");
		this.ignoreNewlines();
		var target = this.expression();
		this.ignoreNewlines();
		this.consume(")","Expect ')' after switch target");
		this.ignoreNewlines();
		this.consume("{","Expect '{'");
		this.ignoreNewlines();
		var cases = [];
		while(!this.isAtEnd() && this.match(["case","default"])) {
			this.ignoreNewlines();
			var condition = null;
			var isDefault = false;
			if(this.previous().type == "default") {
				isDefault = true;
			} else {
				condition = this.expression();
			}
			this.consume(":","Expect a ':' after case condition");
			this.ignoreNewlines();
			var body = [];
			while(!this.isAtEnd() && !this.check("case") && !this.check("default") && !this.check("}")) body.push(this.statement());
			cases.push({ condition : condition, body : body, isDefault : isDefault});
		}
		this.ignoreNewlines();
		this.consume("}","Expect a '}' at the end of switch statement");
		this.ignoreNewlines();
		return new phase_Switch(target,cases);
	}
	,returnStatement: function() {
		var keyword = this.previous();
		var value = null;
		if(!this.check(";") && !this.check("[newline]")) {
			value = this.expression();
		}
		this.expectEndOfStatement();
		return new phase_Return(keyword,value);
	}
	,block: function() {
		this.ignoreNewlines();
		var statements = [];
		while(!this.check("}") && !this.isAtEnd()) statements.push(this.declaration());
		this.ignoreNewlines();
		this.consume("}","Expect '}' at the end of a block.");
		return statements;
	}
	,blockStatement: function() {
		var statements = this.block();
		this.ignoreNewlines();
		return new phase_Block(statements);
	}
	,expressionStatement: function() {
		var expr = this.expression();
		this.expectEndOfStatement();
		return new phase_Expression(expr);
	}
	,expression: function() {
		return this.assignment();
	}
	,assignment: function() {
		var expr = this.or();
		if(this.match(["="])) {
			var equals = this.previous();
			this.ignoreNewlines();
			var value = this.assignment();
			if(((expr) instanceof phase_Variable)) {
				var name = expr.name;
				return new phase_Assign(name,value);
			} else if(((expr) instanceof phase_Get)) {
				var get = expr;
				return new phase_Set(get.object,get.name,value);
			} else if(((expr) instanceof phase_SubscriptGet)) {
				var get = expr;
				return new phase_SubscriptSet(this.previous(),get.object,get.index,value);
			}
			throw haxe_Exception.thrown(this.error(equals,"Invalid assignment target."));
		}
		return expr;
	}
	,or: function() {
		var expr = this.and();
		while(this.match(["||"])) {
			var op = this.previous();
			var right = this.and();
			expr = new phase_Logical(expr,op,right);
		}
		return expr;
	}
	,and: function() {
		var expr = this.equality();
		while(this.match(["&&"])) {
			var op = this.previous();
			var right = this.equality();
			expr = new phase_Logical(expr,op,right);
		}
		return expr;
	}
	,equality: function() {
		var expr = this.comparison();
		while(this.match(["!=","=="])) {
			var op = this.previous();
			var right = this.comparison();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,comparison: function() {
		var expr = this.addition();
		if(this.match(["is"])) {
			var type = this.parseTypePath();
			this.ignoreNewlines();
			return new phase_Is(expr,type);
		}
		while(this.match([">",">=","<","<="])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.addition();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,addition: function() {
		var expr = this.multiplication();
		while(this.match(["-","+","+++"])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.multiplication();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,multiplication: function() {
		var expr = this.range();
		while(this.match(["\\","*"])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.range();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,range: function() {
		var expr = this.pipe();
		while(this.match(["..."])) {
			this.ignoreNewlines();
			var to = this.pipe();
			expr = new phase_Range(expr,to);
		}
		return expr;
	}
	,pipe: function() {
		var expr = this.unary();
		while(this.match(["|>"])) {
			var op = this.previous();
			var target = this.unary();
			switch(js_Boot.getClass(target)) {
			case phase_Call:
				var caller = target;
				caller.args.push(phase_CallArgument.Positional(expr));
				expr = caller;
				break;
			case phase_Lambda:
				expr = new phase_Call(new phase_Grouping(target),op,[phase_CallArgument.Positional(expr)]);
				break;
			default:
				throw haxe_Exception.thrown(this.error(op,"Expected a function/method call or a lambda"));
			}
		}
		return expr;
	}
	,unary: function() {
		if(this.match(["!","-","++","--"])) {
			var op = this.previous();
			this.ignoreNewlines();
			return new phase_Unary(op,this.unary(),true);
		}
		var expr = this.call();
		if(this.match(["++","--"])) {
			var op = this.previous();
			return new phase_Unary(op,expr,false);
		}
		return expr;
	}
	,call: function() {
		var expr = this.primary();
		while(!this.isAtEnd()) {
			this.conditionalIgnoreNewlines();
			if(this.match(["("])) {
				expr = this.finishCall(expr);
			} else if(this.match(["{"])) {
				expr = new phase_Call(expr,this.previous(),[phase_CallArgument.Positional(this.shortLambda(!this.check("[newline]")))]);
			} else if(this.match(["."])) {
				this.ignoreNewlines();
				var name;
				if(this.match(["{"])) {
					this.ignoreNewlines();
					var ret = this.expression();
					if(((ret) instanceof phase_Variable)) {
						ret = new phase_Grouping(ret);
					}
					this.ignoreNewlines();
					this.consume("}","Expect a '}'");
					name = ret;
				} else {
					name = this.match(["[type-identifier]","class"]) ? new phase_Variable(this.previous()) : new phase_Variable(this.consume("[identifier]","Expect property name after '.'."));
				}
				expr = new phase_Get(expr,name);
			} else if(this.match(["["])) {
				if(this.match(["]"])) {
					expr = new phase_SubscriptGet(this.previous(),expr,null);
				} else {
					this.ignoreNewlines();
					var index = this.expression();
					this.ignoreNewlines();
					this.consume("]","Expect ']' after expression");
					expr = new phase_SubscriptGet(this.previous(),expr,index);
				}
			} else {
				break;
			}
		}
		return expr;
	}
	,finishCall: function(callee) {
		var $arguments = [];
		if(!this.check(")")) {
			$arguments = this.parseArguments();
		}
		this.ignoreNewlines();
		var paren = this.consume(")","Expect ')' after arguments.");
		if(this.match(["{"])) {
			$arguments.push(phase_CallArgument.Positional(this.shortLambda(!this.check("[newline]"))));
		}
		return new phase_Call(callee,paren,$arguments);
	}
	,parseArguments: function() {
		var _gthis = this;
		var isAfterNamedArgument = false;
		return this.parseList(",",function() {
			if(_gthis.check("[identifier]") && _gthis.checkNext(":")) {
				isAfterNamedArgument = true;
				_gthis.consume("[identifier]","expected an identifier");
				var name = _gthis.previous().lexeme;
				_gthis.consume(":","expected a \":\"");
				var expr = _gthis.expression();
				return phase_CallArgument.Named(name,expr);
			} else {
				if(isAfterNamedArgument) {
					throw haxe_Exception.thrown(_gthis.error(_gthis.peek(),"Positional arguments cannot come after named ones"));
				}
				return phase_CallArgument.Positional(_gthis.expression());
			}
		});
	}
	,taggedTemplate: function(callee) {
		var firstTok = this.peek();
		var parts = [];
		var placeholders = [];
		if(!this.check("[string]")) {
			while(true) {
				if(this.match(["[interpolation]"])) {
					parts.push(new phase_Literal(this.previous().literal));
				} else {
					placeholders.push(this.expression());
				}
				if(!(!this.check("[string]") && !this.isAtEnd())) {
					break;
				}
			}
		}
		parts.push(this.primary());
		return new phase_Call(callee,firstTok,[phase_CallArgument.Positional(new phase_ArrayLiteral(firstTok,parts)),phase_CallArgument.Positional(new phase_ArrayLiteral(firstTok,placeholders))]);
	}
	,interpolation: function(expr) {
		while(!this.isAtEnd()) {
			var next;
			if(this.match(["[string]"])) {
				return new phase_Binary(expr,new phase_Token("+++","+++",null,this.previous().pos),new phase_Literal(this.previous().literal));
			} else if(this.match(["[interpolation]"])) {
				next = new phase_Literal(this.previous().literal);
			} else {
				next = new phase_Grouping(this.expression());
			}
			expr = new phase_Binary(expr,new phase_Token("+++","+++",null,this.peek().pos),next);
		}
		this.error(this.peek(),"Unexpected end of interpolated string");
		return expr;
	}
	,primary: function() {
		if(this.match(["false"])) {
			return new phase_Literal(false);
		}
		if(this.match(["true"])) {
			return new phase_Literal(true);
		}
		if(this.match(["null"])) {
			return new phase_Literal(null);
		}
		if(this.match(["[number]","[string]"])) {
			return new phase_Literal(this.previous().literal);
		}
		if(this.match(["[interpolation]"])) {
			return this.interpolation(new phase_Literal(this.previous().literal));
		}
		if(this.match(["super"])) {
			var keyword = this.previous();
			this.consume(".","Expect '.' after 'super'.");
			this.ignoreNewlines();
			var method = this.consume("[identifier]","Expect superclass method name.");
			return new phase_Super(keyword,method);
		}
		if(this.match(["this"])) {
			return new phase_This(this.previous());
		}
		if(this.match(["static"])) {
			return new phase_Static(this.previous());
		}
		if(this.match(["::"])) {
			return this.namespacedExprOrType(true);
		}
		if(this.check("[type-identifier]")) {
			return this.namespacedExprOrType(false);
		}
		if(this.match(["[identifier]"])) {
			return new phase_Variable(this.previous());
		}
		if(this.match(["[template]"])) {
			return this.taggedTemplate(new phase_Variable(this.previous()));
		}
		if(this.match(["("])) {
			this.ignoreNewlines();
			var expr = this.expression();
			this.ignoreNewlines();
			this.consume(")","Expect ')' after expression.");
			return new phase_Grouping(expr);
		}
		if(this.match(["["])) {
			return this.arrayOrAssocLiteral();
		}
		if(this.match(["{"])) {
			return this.shortLambda(!this.check("[newline]"));
		}
		if(this.match(["function"])) {
			return new phase_Lambda(this.functionDef(true));
		}
		if(this.match(["if"])) {
			return this.ternary();
		}
		var tok = this.peek();
		throw haxe_Exception.thrown(this.error(tok,"Unexpected " + tok.type));
	}
	,namespacedExprOrType: function(isAbsolute) {
		var path = [this.consume("[type-identifier]","Expect at least one type identifier")];
		while(this.check("::") && this.checkNext("[type-identifier]") && !this.isAtEnd()) {
			this.advance();
			path.push(this.advance());
		}
		var type = new phase_Type(path,isAbsolute);
		if(this.match(["::"])) {
			var tok = this.consume("[identifier]","Expect an identifier");
			return new phase_Namespaced(type,tok);
		}
		return type;
	}
	,ternary: function() {
		this.consume("(","Expect '(' after 'if'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after if condition.");
		this.ignoreNewlines();
		var thenBranch = this.expression();
		this.ignoreNewlines();
		this.consume("else","Expected an 'else' branch");
		this.ignoreNewlines();
		var elseBranch = this.expression();
		return new phase_Ternary(condition,thenBranch,elseBranch);
	}
	,arrayOrAssocLiteral: function() {
		this.ignoreNewlines();
		if(this.checkNext(":")) {
			return this.assocArrayLiteral();
		}
		return this.arrayLiteral();
	}
	,arrayLiteral: function() {
		var values = [];
		if(!this.check("]")) {
			values = this.parseList(",",$bind(this,this.expression));
		}
		this.ignoreNewlines();
		var end = this.consume("]","Expect ']' after values.");
		return new phase_ArrayLiteral(end,values);
	}
	,assocArrayLiteral: function() {
		var keys = [];
		var values = [];
		if(!this.check("]")) {
			while(true) {
				this.ignoreNewlines();
				keys.push(this.expression());
				this.consume(":","Expect colons after object keys");
				this.ignoreNewlines();
				values.push(this.expression());
				if(!this.match([","])) {
					break;
				}
			}
			this.ignoreNewlines();
		}
		var end = this.consume("]","Expect ']' at the end of an assoc array literal");
		return new phase_AssocArrayLiteral(end,keys,values);
	}
	,shortLambda: function(isInline) {
		if(isInline == null) {
			isInline = false;
		}
		this.ignoreNewlines();
		var params = [];
		var maybeNeedIt = false;
		if(this.match(["|"])) {
			if(!this.check("|")) {
				while(true) {
					params.push({ name : this.consume("[identifier]","Expect parameter name"), type : null, expr : null});
					if(!this.match([","])) {
						break;
					}
				}
			}
			this.consume("|","Expect '|' after parameters");
			isInline = !this.check("[newline]");
		} else {
			params = [{ name : new phase_Token("[identifier]","it",null,this.previous().pos), type : null, expr : new phase_Literal(null)}];
		}
		var body = [];
		if(isInline && !this.check("return")) {
			body.push(new phase_Return(this.peek(),this.expression()));
			this.ignoreNewlines();
			this.consume("}","Inline lambdas must contain only one expression.");
		} else {
			body = this.block();
		}
		return new phase_Lambda(new phase_Function(new phase_Token("[identifier]","",null,this.previous().pos),params,new phase_Block(body),null,[]));
	}
	,typeHint: function() {
		if(this.match([":"])) {
			return this.parseTypePath();
		}
		return null;
	}
	,parseTypePath: function() {
		var _gthis = this;
		var absolute = this.match(["::"]);
		var path = this.parseList("::",function() {
			return _gthis.consume("[type-identifier]","Expect a TypeIdentifier");
		});
		return new phase_Type(path,absolute);
	}
	,tempVar: function(prefix) {
		this.uid++;
		return "" + prefix + "_" + this.uid;
	}
	,synchronize: function() {
		this.advance();
		while(!this.isAtEnd()) {
			if(this.previous().type == ";") {
				return;
			}
			if(this.previous().type == "[newline]") {
				return;
			}
			switch(this.peek().type) {
			case "class":case "for":case "function":case "if":case "return":case "switch":case "var":case "while":
				return;
			default:
				this.advance();
			}
		}
	}
	,parseList: function(sep,parser) {
		var items = [];
		while(true) {
			this.ignoreNewlines();
			items.push(parser());
			if(!(this.match([sep]) && !this.isAtEnd())) {
				break;
			}
		}
		return items;
	}
	,conditionalIgnoreNewlines: function() {
		var _gthis = this;
		if(this.check("[newline]")) {
			while(!this.isAtEnd()) {
				if(this.checkNext("[newline]")) {
					this.advance();
				}
				if(Lambda.exists(phase_Parser.continuationTokens,function(f) {
					return _gthis.checkNext(f);
				})) {
					this.advance();
					return;
				}
				if(!this.checkNext("[newline]")) {
					return;
				}
			}
		}
	}
	,ignoreNewlines: function() {
		while(!this.isAtEnd()) if(!this.match(["[newline]"])) {
			return;
		}
	}
	,expectEndOfStatement: function() {
		if(this.check("}")) {
			return true;
		}
		if(this.match(["[newline]","[eof]"])) {
			this.ignoreNewlines();
			return true;
		}
		this.consume(";","Expect newline or semicolon after statement");
		this.ignoreNewlines();
		return false;
	}
	,match: function(types) {
		var _g = 0;
		while(_g < types.length) {
			var type = types[_g];
			++_g;
			if(this.check(type)) {
				this.advance();
				return true;
			}
		}
		return false;
	}
	,consume: function(type,message) {
		if(this.check(type)) {
			return this.advance();
		}
		throw haxe_Exception.thrown(this.error(this.peek(),message));
	}
	,check: function(type) {
		if(this.isAtEnd()) {
			return false;
		}
		return this.peek().type == type;
	}
	,checkNext: function(type) {
		if(this.isAtEnd()) {
			return false;
		}
		return this.peekNext().type == type;
	}
	,advance: function() {
		if(!this.isAtEnd()) {
			this.current++;
		}
		return this.previous();
	}
	,peek: function() {
		return this.tokens[this.current];
	}
	,peekNext: function() {
		return this.tokens[this.current + 1];
	}
	,previous: function() {
		return this.tokens[this.current - 1];
	}
	,isAtEnd: function() {
		return this.peek().type == "[eof]";
	}
	,error: function(token,message) {
		this.reporter.report(token.pos,token.lexeme,message);
		return new phase_ParserError();
	}
	,__class__: phase_Parser
};
var phase_ParserError = function() {
};
phase_ParserError.__name__ = true;
phase_ParserError.prototype = {
	__class__: phase_ParserError
};
var phase_GeneratorMode = $hxEnums["phase.GeneratorMode"] = { __ename__:true,__constructs__:null
	,GeneratingRoot: {_hx_name:"GeneratingRoot",_hx_index:0,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingClass: {_hx_name:"GeneratingClass",_hx_index:1,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingInterface: {_hx_name:"GeneratingInterface",_hx_index:2,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingTrait: {_hx_name:"GeneratingTrait",_hx_index:3,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingClosure: {_hx_name:"GeneratingClosure",_hx_index:4,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingFunction: {_hx_name:"GeneratingFunction",_hx_index:5,__enum__:"phase.GeneratorMode",toString:$estr}
};
phase_GeneratorMode.__constructs__ = [phase_GeneratorMode.GeneratingRoot,phase_GeneratorMode.GeneratingClass,phase_GeneratorMode.GeneratingInterface,phase_GeneratorMode.GeneratingTrait,phase_GeneratorMode.GeneratingClosure,phase_GeneratorMode.GeneratingFunction];
var phase_PhpGenerator = function(stmts,reporter,options) {
	this.exprKind = new haxe_ds_ObjectMap();
	this.append = [];
	this.uid = 0;
	this.indentLevel = 0;
	this.closureCaptures = [];
	this.mode = phase_GeneratorMode.GeneratingRoot;
	this.options = options == null ? { } : options;
	this.stmts = stmts;
	this.reporter = reporter;
	if(this.options.version == null) {
		this.options.version = "8";
	}
	if(this.options.attribute == null) {
		var tmp;
		switch(this.options.version) {
		case "7":
			tmp = "on-class";
			break;
		case "8":
			tmp = "attribute";
			break;
		}
		this.options.attribute = tmp;
	}
};
phase_PhpGenerator.__name__ = true;
phase_PhpGenerator.prototype = {
	generate: function() {
		this.append = [];
		this.exprKind = new haxe_ds_ObjectMap();
		this.scope = new phase_PhpScope();
		var out = [];
		var _g = 0;
		var _g1 = this.stmts;
		while(_g < _g1.length) {
			var stmt = _g1[_g];
			++_g;
			var s = this.generateStmt(stmt);
			if(s != null && s != "") {
				out.push(s);
			}
		}
		return "<?php\n" + out.concat(this.append).join("\n");
	}
	,generateStmt: function(stmt) {
		if(stmt == null) {
			return "";
		}
		return stmt.accept(this);
	}
	,generateExpr: function(expr) {
		if(expr == null) {
			return "";
		}
		return expr.accept(this);
	}
	,visitNamespaceStmt: function(stmt) {
		var _gthis = this;
		var _this = stmt.path;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].lexeme;
		}
		var out = "namespace " + result.join("\\") + " {\n\n";
		this.scope.push();
		this.indent();
		var _this = stmt.decls;
		var f = $bind(this,this.generateStmt);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		out += result.join("\n");
		this.scope.pop();
		if(this.append.length > 0) {
			var _this = this.append;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _gthis.getIndent() + _this[i];
			}
			out += "\n\n" + result.join("\n");
			this.append = [];
		}
		this.outdent();
		return out + "\n\n" + this.getIndent() + "}";
	}
	,visitBlockStmt: function(stmt) {
		var out = this.getIndent() + "{\n";
		this.scope.push();
		this.indent();
		var _this = stmt.statements;
		var f = $bind(this,this.generateStmt);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		out += result.join("\n") + "\n";
		this.outdent();
		this.scope.pop();
		out += this.getIndent() + "}";
		return out;
	}
	,visitExpressionStmt: function(stmt) {
		return this.getIndent() + this.generateExpr(stmt.expression) + ";";
	}
	,visitIfStmt: function(stmt) {
		var out = this.getIndent() + "if (" + this.generateExpr(stmt.condition) + ")\n" + this.generateStmt(stmt.thenBranch);
		if(stmt.elseBranch != null) {
			out += "\n" + this.getIndent() + "else\n" + this.generateStmt(stmt.elseBranch);
		}
		return out;
	}
	,visitReturnStmt: function(stmt) {
		return this.getIndent() + (stmt.value == null ? "return;" : "return " + this.generateExpr(stmt.value) + ";");
	}
	,visitVarStmt: function(stmt) {
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpVar);
		return this.getIndent() + "$" + this.safeVar(stmt.name) + " = " + (stmt.initializer != null ? this.generateExpr(stmt.initializer) : "null") + ";";
	}
	,visitGlobalStmt: function(stmt) {
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpVar);
		return this.getIndent() + "global $" + this.safeVar(stmt.name) + ";";
	}
	,visitUseStmt: function(stmt) {
		var _gthis = this;
		var _this = stmt.path;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].lexeme;
		}
		var path = result.join("\\");
		if(stmt.absolute) {
			path = "\\" + path;
		}
		var _g = stmt.kind;
		switch(_g._hx_index) {
		case 0:
			var name = stmt.path[stmt.path.length - 1].lexeme;
			this.scope.define(name,phase_PhpKind.PhpType);
			return this.getIndent() + ("use " + path + ";");
		case 1:
			var target = _g.alias;
			switch(target._hx_index) {
			case 0:
				var alias = target.name;
				this.scope.define(alias.lexeme,phase_PhpKind.PhpType);
				return this.getIndent() + ("use " + path + " as " + alias.lexeme + ";");
			case 1:
				var alias = target.name;
				this.scope.define(alias.lexeme,phase_PhpKind.PhpFun);
				return this.getIndent() + ("use function " + path + " as " + alias.lexeme + ";");
			}
			break;
		case 2:
			var items = _g.items;
			var result = new Array(items.length);
			var _g = 0;
			var _g1 = items.length;
			while(_g < _g1) {
				var i = _g++;
				var target = items[i];
				var tmp;
				switch(target._hx_index) {
				case 0:
					var f = target.name;
					_gthis.scope.define(f.lexeme,phase_PhpKind.PhpType);
					tmp = _gthis.getIndent() + ("use " + path + "\\" + f.lexeme + ";");
					break;
				case 1:
					var f1 = target.name;
					_gthis.scope.define(f1.lexeme,phase_PhpKind.PhpFun);
					tmp = _gthis.getIndent() + ("use function " + path + "\\" + f1.lexeme + ";");
					break;
				}
				result[i] = tmp;
			}
			return result.join("\n");
		}
	}
	,visitClassStmt: function(stmt) {
		var out = "";
		var props = [];
		if(stmt.attribute.length > 0) {
			out += this.generateAttributes({ cls : stmt},stmt.attribute);
		}
		var keyword;
		switch(stmt.kind._hx_index) {
		case 0:
			keyword = "class";
			break;
		case 1:
			keyword = "interface";
			break;
		case 2:
			keyword = "trait";
			break;
		}
		out += "\n" + this.getIndent() + keyword + " " + stmt.name.lexeme;
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpType);
		if(stmt.superclass != null) {
			out += " extends " + stmt.superclass.lexeme;
		}
		if(stmt.interfaces.length > 0) {
			var out1;
			switch(stmt.kind._hx_index) {
			case 0:
				out1 = " implements ";
				break;
			case 1:
				out1 = " extends ";
				break;
			case 2:
				out1 = "";
				break;
			}
			out += out1;
			var _this = stmt.interfaces;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i].lexeme;
			}
			out += result.join(", ");
		}
		out += "\n" + this.getIndent() + "{\n";
		this.indent();
		this.scope.push();
		var prevMode = this.mode;
		var tmp;
		switch(stmt.kind._hx_index) {
		case 0:
			tmp = phase_GeneratorMode.GeneratingClass;
			break;
		case 1:
			tmp = phase_GeneratorMode.GeneratingInterface;
			break;
		case 2:
			tmp = phase_GeneratorMode.GeneratingTrait;
			break;
		}
		this.mode = tmp;
		var _g = 0;
		var _g1 = stmt.fields;
		while(_g < _g1.length) {
			var field = _g1[_g];
			++_g;
			if(field.attribute.length > 0) {
				out += this.generateAttributes({ cls : stmt, field : field.name.lexeme},field.attribute);
			}
			var _g2 = field.kind;
			if(_g2._hx_index == 2) {
				var _g3 = _g2.getter;
				var _g4 = _g2.setter;
				var _g5 = _g2.type;
				props.push(this.safeVar(field.name));
			}
			out += this.generateStmt(field) + "\n";
		}
		if(props.length > 0) {
			out += "\n" + this.getIndent() + "public function __get($prop)";
			out += "\n" + this.getIndent() + "{";
			this.indent();
			out += "\n" + this.getIndent() + "return $this->{'__get_' . $prop}();";
			this.outdent();
			out += "\n" + this.getIndent() + "}";
			out += "\n";
			out += "\n" + this.getIndent() + "public function __set($prop, $value)";
			out += "\n" + this.getIndent() + "{";
			this.indent();
			out += "\n" + this.getIndent() + "$this->{'__set_' . $prop}($value);";
			this.outdent();
			out += "\n" + this.getIndent() + "}";
		}
		this.mode = prevMode;
		this.scope.pop();
		this.outdent();
		return out + "\n" + this.getIndent() + "}";
	}
	,visitFieldStmt: function(stmt) {
		var _gthis = this;
		var isConst = false;
		var access = "\n" + this.getIndent();
		var _this = stmt.access;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var access1;
			switch(_this[i]._hx_index) {
			case 0:
				access1 = "static";
				break;
			case 1:
				access1 = "public";
				break;
			case 2:
				access1 = "protected";
				break;
			case 3:
				access1 = _gthis.mode == phase_GeneratorMode.GeneratingInterface ? null : "abstract";
				break;
			case 4:
				isConst = true;
				access1 = "const";
				break;
			}
			result[i] = access1;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = result;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != null) {
				_g.push(v);
			}
		}
		var access1 = access + _g.join(" ");
		var _g = stmt.kind;
		switch(_g._hx_index) {
		case 0:
			var type = _g.type;
			return "use " + this.generateTypePath(type) + ";";
		case 1:
			var v = _g.v;
			var t = _g.type;
			var _g1 = this.options.version;
			var out = access1 + (_g1 == null ? "" : _g1 == "8" ? t != null && !isConst ? " " + this.generateTypePath(t) : "" : "");
			out += isConst ? " " + this.safeVar(stmt.name) : " $" + this.safeVar(stmt.name);
			if(v.initializer != null) {
				out += " = " + this.generateExpr(v.initializer);
			}
			return out + ";";
		case 2:
			var getter = _g.getter;
			var setter = _g.setter;
			var type = _g.type;
			var name = this.safeVar(stmt.name);
			var ret = type != null ? ":" + this.generateTypePath(type) : "";
			var out = "";
			if(getter != null) {
				this.scope.push();
				out += access1 + (" function __get_" + name + "()" + ret + " \n") + this.generateStmt(getter.body);
				this.scope.pop();
			}
			if(setter != null) {
				this.scope.push();
				out += access1 + (" function __set_" + name + "(") + this.functionParams(setter.params) + ") \n" + this.generateStmt(setter.body);
				this.scope.pop();
			}
			return out;
		case 3:
			var fun = _g.fun;
			var name = stmt.name.lexeme == "new" ? "__construct" : this.safeVar(stmt.name);
			this.scope.push();
			var out = access1 + " function " + name + "(" + this.functionParams(fun.params) + ")";
			if(fun.ret != null) {
				out += ":" + this.generateTypePath(fun.ret);
			}
			if(stmt.access.indexOf(phase_FieldAccess.AAbstract) < 0) {
				var body = fun.body;
				var _g = 0;
				var _g1 = fun.params;
				while(_g < _g1.length) {
					var p = _g1[_g];
					++_g;
					if(p.isInit == true) {
						var init = new phase_Expression(new phase_Set(new phase_This(p.name),new phase_Variable(p.name),new phase_Variable(p.name)));
						body.statements.unshift(init);
					}
				}
				out += "\n" + this.generateStmt(body);
			} else {
				out += ";";
			}
			this.scope.pop();
			return out;
		}
	}
	,visitFunctionStmt: function(stmt) {
		this.scope.define(this.safeVar(stmt.name),phase_PhpKind.PhpFun);
		this.scope.push();
		var prevMode = this.mode;
		this.mode = phase_GeneratorMode.GeneratingFunction;
		var out = "\n" + this.getIndent() + "function " + this.safeVar(stmt.name) + "(" + this.functionParams(stmt.params) + ")\n";
		out += this.generateStmt(stmt.body);
		this.mode = prevMode;
		this.scope.pop();
		return out;
	}
	,functionParams: function(params) {
		var _gthis = this;
		var result = new Array(params.length);
		var _g = 0;
		var _g1 = params.length;
		while(_g < _g1) {
			var i = _g++;
			var param = params[i];
			var name = _gthis.safeVar(param.name);
			_gthis.scope.define(name,phase_PhpKind.PhpVar);
			var out = param.type != null ? _gthis.generateTypePath(param.type) + " $" + name : "$" + name;
			if(param.expr != null) {
				out += " = " + _gthis.generateExpr(param.expr);
			}
			result[i] = out;
		}
		return result.join(", ");
	}
	,visitThrowStmt: function(stmt) {
		return this.getIndent() + "throw " + this.generateExpr(stmt.expr) + ";";
	}
	,visitTryStmt: function(stmt) {
		var out = this.getIndent() + "try\n";
		out += this.generateStmt(stmt.body);
		var _g = 0;
		var _g1 = stmt.catches;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			this.scope.push();
			var name = this.safeVar(c.name);
			this.scope.define(name,phase_PhpKind.PhpVar);
			out += "\n" + this.getIndent() + "catch (";
			if(c.type != null) {
				out += this.generateTypePath(c.type) + " $" + name + ")\n";
			} else {
				out += "$" + name + ")\n";
			}
			out += this.generateStmt(c.body);
			this.scope.pop();
		}
		return out;
	}
	,visitWhileStmt: function(stmt) {
		return this.getIndent() + "while (" + this.generateExpr(stmt.condition) + ")\n" + this.generateStmt(stmt.body);
	}
	,visitForStmt: function(stmt) {
		if(js_Boot.getClass(stmt.target) == phase_Range) {
			this.scope.push();
			var range = stmt.target;
			var key = this.safeVar(stmt.key);
			var init = this.generateExpr(range.from);
			var limit = this.generateExpr(range.to);
			this.scope.define(key,phase_PhpKind.PhpVar);
			var out = this.getIndent() + "for ($" + key + " = " + init + ";" + " $" + key + " < " + limit + "; $" + key + "++)\n" + this.generateStmt(stmt.body);
			this.scope.pop();
			return out;
		} else {
			this.scope.push();
			var key = this.safeVar(stmt.key);
			var out = this.getIndent() + "foreach (" + this.generateExpr(stmt.target) + " as $" + key;
			this.scope.define(key,phase_PhpKind.PhpVar);
			if(stmt.value != null) {
				var value = this.safeVar(stmt.value);
				this.scope.define(value,phase_PhpKind.PhpVar);
				out += " => $" + value;
			}
			out += ")\n" + this.generateStmt(stmt.body);
			this.scope.pop();
			return out;
		}
	}
	,visitSwitchStmt: function(stmt) {
		var out = this.getIndent() + "switch (" + this.generateExpr(stmt.target) + ")\n" + this.getIndent() + "{\n";
		this.indent();
		var _g = 0;
		var _g1 = stmt.cases;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isDefault) {
				out += this.getIndent() + "default:\n";
			} else {
				out += this.getIndent() + "case " + this.generateExpr(c.condition) + ":\n";
			}
			this.indent();
			var _this = c.body;
			var f = $bind(this,this.generateStmt);
			var result = new Array(_this.length);
			var _g2 = 0;
			var _g11 = _this.length;
			while(_g2 < _g11) {
				var i = _g2++;
				result[i] = f(_this[i]);
			}
			out += result.join("") + "\n";
			out += this.getIndent() + "break;\n";
			this.outdent();
		}
		this.outdent();
		out += this.getIndent() + "}";
		return out;
	}
	,visitAttributeExpr: function(expr) {
		var _gthis = this;
		var _this = expr.path;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].lexeme;
		}
		var name = result.join("\\");
		var generateArg = function(arg) {
			switch(arg._hx_index) {
			case 0:
				var expr = arg.expr;
				return _gthis.generateExpr(expr);
			case 1:
				var name = arg.name;
				var expr = arg.expr;
				return "" + name + ": " + _gthis.generateExpr(expr);
			}
		};
		switch(this.options.attribute) {
		case "attribute":
			var tmp = name + "(";
			var _this = expr.params;
			var f = generateArg;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			return tmp + result.join(", ") + ")";
		case "docblock":
			var tmp = "@" + name + "(";
			var _this = expr.params;
			var f = generateArg;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			return tmp + result.join(", ") + ")";
		case "on-class":case "phase":
			var tmp = this.tempVar("attribute");
			this.indent();
			var out = "";
			var out1 = this.getIndent() + "$" + tmp + " = new " + name + "(";
			var _this = expr.params;
			var f = generateArg;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			out = out1 + result.join(", ") + ");\n" + out;
			out += this.getIndent() + "return $" + tmp + ";\n";
			this.outdent();
			return "(function () {\n" + out + this.getIndent() + "})()";
		}
	}
	,visitArrayLiteralExpr: function(expr) {
		return "[" + this.generateList(expr.values) + "]";
	}
	,visitAssocArrayLiteralExpr: function(expr) {
		this.indent();
		var _g = [];
		var _g1 = 0;
		var _g2 = expr.keys.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var key = expr.keys[i];
			var value = expr.values[i];
			_g.push(this.getIndent() + ("" + this.generateExpr(key) + " => " + this.generateExpr(value)));
		}
		var out = "[\n" + _g.join(",\n");
		this.outdent();
		return out + "\n" + this.getIndent() + "]";
	}
	,visitAssignExpr: function(expr) {
		var name = this.safeVar(expr.name);
		var kind = this.scope.get(name);
		if(kind != phase_PhpKind.PhpVar) {
			throw haxe_Exception.thrown(this.error(expr.name,"Invalid assignment"));
		}
		return "$" + name + (" = " + this.generateExpr(expr.value));
	}
	,visitIsExpr: function(expr) {
		return this.generateExpr(expr.left) + " instanceof " + this.generateExpr(expr.type);
	}
	,visitBinaryExpr: function(expr) {
		var op = expr.op.type == "+++" ? "." : expr.op.lexeme;
		return this.generateExpr(expr.left) + " " + op + " " + this.generateExpr(expr.right);
	}
	,visitCallExpr: function(expr) {
		var _gthis = this;
		var callee;
		switch(js_Boot.getClass(expr.callee)) {
		case phase_Get:
			var getter = expr.callee;
			switch(js_Boot.getClass(getter.object)) {
			case phase_Static:case phase_Type:
				callee = this.generateExpr(getter.object) + "::" + this.getProperty(getter.name);
				break;
			default:
				callee = this.generateExpr(getter.object) + "->" + this.getProperty(getter.name);
			}
			break;
		case phase_Type:
			callee = "new " + this.generateExpr(expr.callee);
			break;
		default:
			callee = this.generateExpr(expr.callee);
		}
		var tmp = "" + callee + "(";
		var _this = expr.args;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var arg = _this[i];
			var tmp1;
			switch(arg._hx_index) {
			case 0:
				var expr = arg.expr;
				tmp1 = _gthis.generateExpr(expr);
				break;
			case 1:
				var name = arg.name;
				var expr1 = arg.expr;
				tmp1 = "" + name + ": " + _gthis.generateExpr(expr1);
				break;
			}
			result[i] = tmp1;
		}
		return tmp + result.join(", ") + ")";
	}
	,visitGetExpr: function(expr) {
		switch(js_Boot.getClass(expr.object)) {
		case phase_Static:case phase_Type:
			return this.generateExpr(expr.object) + "::" + this.getProperty(expr.name,true);
		default:
			return this.generateExpr(expr.object) + "->" + this.getProperty(expr.name);
		}
	}
	,visitSetExpr: function(expr) {
		var left;
		switch(js_Boot.getClass(expr.object)) {
		case phase_Static:case phase_Type:
			left = this.generateExpr(expr.object) + "::" + this.getProperty(expr.name,true);
			break;
		default:
			left = this.generateExpr(expr.object) + "->" + this.getProperty(expr.name);
		}
		return left + " = " + this.generateExpr(expr.value);
	}
	,getProperty: function(expr,isStatic) {
		if(isStatic == null) {
			isStatic = false;
		}
		if(js_Boot.getClass(expr) == phase_Variable) {
			var e = expr;
			switch(e.name.type) {
			case "[type-identifier]":
				return this.safeVar(e.name);
			case "class":
				return "class";
			default:
				if(isStatic) {
					return "$" + this.safeVar(e.name);
				} else {
					return this.safeVar(e.name);
				}
			}
		} else {
			return "{" + this.generateExpr(expr) + "}";
		}
	}
	,visitSubscriptGetExpr: function(expr) {
		if(expr.index == null) {
			return this.generateExpr(expr.object) + "[]";
		}
		return this.generateExpr(expr.object) + "[" + this.generateExpr(expr.index) + "]";
	}
	,visitSubscriptSetExpr: function(expr) {
		var left = expr.index == null ? this.generateExpr(expr.object) + "[]" : this.generateExpr(expr.object) + "[" + this.generateExpr(expr.index) + "]";
		return left + " = " + this.generateExpr(expr.value);
	}
	,visitGroupingExpr: function(expr) {
		return "(" + this.generateExpr(expr.expression) + ")";
	}
	,visitLambdaExpr: function(expr) {
		var _gthis = this;
		var func = expr.func;
		var prevCaptures = this.closureCaptures;
		var prevMode = this.mode;
		var prevDepth = this.localDepth;
		this.closureCaptures = this.closureCaptures.slice();
		this.mode = phase_GeneratorMode.GeneratingClosure;
		this.scope.push();
		this.localDepth = this.scope.getTop().depth;
		var out = "function (" + this.functionParams(func.params) + ")";
		var body = this.generateStmt(func.body);
		if(this.closureCaptures.length > 0) {
			var uniq = [];
			var _g = 0;
			var _g1 = this.closureCaptures;
			while(_g < _g1.length) {
				var name = _g1[_g];
				++_g;
				if(uniq.indexOf(name) < 0) {
					uniq.push(name);
				}
			}
			var result = new Array(uniq.length);
			var _g = 0;
			var _g1 = uniq.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = "$" + uniq[i];
			}
			out += " use (" + result.join(", ") + ")";
		}
		out += "\n" + body;
		this.localDepth = prevDepth;
		this.scope.pop();
		this.mode = prevMode;
		if(prevMode._hx_index == 4) {
			var _g = [];
			var _g1 = 0;
			var _g2 = this.closureCaptures;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(!_gthis.isLocal(v)) {
					_g.push(v);
				}
			}
			this.closureCaptures = prevCaptures.concat(_g);
		} else {
			this.closureCaptures = [];
		}
		return out;
	}
	,visitNamespacedExpr: function(expr) {
		return this.generateExpr(expr.type) + "\\" + this.safeVar(expr.name);
	}
	,visitTernaryExpr: function(expr) {
		return this.generateExpr(expr.condition) + " ? " + this.generateExpr(expr.thenBranch) + " : " + this.generateExpr(expr.elseBranch);
	}
	,visitLiteralExpr: function(expr) {
		var v = expr.value;
		if(typeof(v) == "number" && ((v | 0) === v)) {
			return expr.value;
		} else if(typeof(expr.value) == "boolean") {
			return expr.value;
		} else if(expr.value == null) {
			return "null";
		} else {
			var value = expr.value;
			return "\"" + StringTools.replace(value,"\"","\\\"") + "\"";
		}
	}
	,visitLogicalExpr: function(expr) {
		return this.generateExpr(expr.left) + " " + expr.op.lexeme + " " + this.generateExpr(expr.right);
	}
	,visitSuperExpr: function(expr) {
		var method = expr.method.lexeme;
		if(method == "new") {
			method = "__construct";
		}
		return "parent::" + method;
	}
	,visitThisExpr: function(expr) {
		return "$this";
	}
	,visitStaticExpr: function(expr) {
		return "static";
	}
	,visitTypeExpr: function(expr) {
		return this.generateTypePath(expr);
	}
	,visitUnaryExpr: function(expr) {
		if(expr.right) {
			return expr.op.lexeme + this.generateExpr(expr.expr);
		} else {
			return this.generateExpr(expr.expr) + expr.op.lexeme;
		}
	}
	,visitRangeExpr: function(expr) {
		return "range(" + this.generateExpr(expr.from) + "," + this.generateExpr(expr.to) + ")";
	}
	,visitVariableExpr: function(expr) {
		var name = this.safeVar(expr.name);
		var kind = this.scope.get(name);
		if(kind == null) {
			kind = phase_PhpKind.PhpFun;
		} else if(this.mode == phase_GeneratorMode.GeneratingClosure) {
			if(!this.isLocal(name) && kind != phase_PhpKind.PhpFun) {
				if(this.closureCaptures.indexOf(name) == -1) {
					this.closureCaptures.push(name);
				}
			}
		}
		if(kind._hx_index == 2) {
			return "$" + name;
		} else {
			return name;
		}
	}
	,generateTypePath: function(t) {
		var _this = t.path;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].lexeme;
		}
		var type = result.join("\\");
		if(Object.prototype.hasOwnProperty.call(phase_PhpGenerator.typeAliases.h,type)) {
			return phase_PhpGenerator.typeAliases.h[type];
		}
		if(t.absolute) {
			type = "\\" + type;
		}
		return type;
	}
	,generateAttributes: function(target,attributes) {
		var clsName = target.cls.name.lexeme;
		if(this.options.attribute == "on-class") {
			if(!Lambda.exists(target.cls.fields,function(f) {
				return f.name.lexeme == "__attributes__";
			})) {
				var pos = target.cls.name.pos;
				var tok = new phase_Token("[identifier]","__attributes__","",pos);
				target.cls.fields.push(new phase_Field(tok,phase_FieldKind.FVar(new phase_Var(tok,new phase_ArrayLiteral(tok,[])),null),[phase_FieldAccess.APublic,phase_FieldAccess.AStatic],[]));
			}
		}
		switch(this.options.attribute) {
		case "attribute":
			var out = "";
			var _g = 0;
			while(_g < attributes.length) {
				var a = attributes[_g];
				++_g;
				out += "\n" + this.getIndent() + "#[" + this.generateExpr(a) + "]";
			}
			return out;
		case "docblock":
			var out = "\n" + this.getIndent() + "/**";
			var _g = 0;
			while(_g < attributes.length) {
				var a = attributes[_g];
				++_g;
				out += "\n" + this.getIndent() + " * " + this.generateExpr(a);
			}
			out += "\n" + this.getIndent() + " */";
			return out;
		case "on-class":
			var kind = target.field == null ? "__CLASS__" : target.field;
			var reg = "" + clsName + "::$" + "__attributes__[\"" + kind + "\"] = " + this.visitArrayLiteralExpr(new phase_ArrayLiteral(target.cls.name,attributes)) + ";";
			this.append.push(reg);
			return "";
		case "phase":
			var kind = target.field == null ? "__CLASS__" : target.field;
			var reg = "\\Phase\\Boot::registerAttribute(" + clsName + "::class, \"" + kind + "\", " + this.visitArrayLiteralExpr(new phase_ArrayLiteral(target.cls.name,attributes)) + ");";
			this.append.push(reg);
			return "";
		}
	}
	,generateList: function(items) {
		var f = $bind(this,this.generateExpr);
		var result = new Array(items.length);
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(items[i]);
		}
		return result.join(", ");
	}
	,safeVar: function(tok) {
		var name = tok.lexeme;
		return name;
	}
	,isLocal: function(name) {
		if(this.localDepth != null) {
			var locals = this.scope.getAt(this.localDepth);
			if(locals == null) {
				return false;
			}
			return locals.get(name) != null;
		}
		return this.scope.getTop().get(name) != null;
	}
	,tempVar: function(prefix) {
		this.uid++;
		return "__" + prefix + "_" + this.uid;
	}
	,getIndent: function() {
		var out = "";
		var _g = 0;
		var _g1 = this.indentLevel;
		while(_g < _g1) {
			var i = _g++;
			out += "  ";
		}
		return out;
	}
	,indent: function() {
		this.indentLevel++;
		return this;
	}
	,outdent: function() {
		this.indentLevel--;
		if(this.indentLevel < 0) {
			this.indentLevel = 0;
		}
		return this;
	}
	,error: function(token,message) {
		this.reporter.report(token.pos,token.lexeme,message);
		return new phase_GeneratorError();
	}
	,__class__: phase_PhpGenerator
};
var phase_GeneratorError = function() {
};
phase_GeneratorError.__name__ = true;
phase_GeneratorError.prototype = {
	__class__: phase_GeneratorError
};
var phase_PhpKind = $hxEnums["phase.PhpKind"] = { __ename__:true,__constructs__:null
	,PhpType: {_hx_name:"PhpType",_hx_index:0,__enum__:"phase.PhpKind",toString:$estr}
	,PhpFun: {_hx_name:"PhpFun",_hx_index:1,__enum__:"phase.PhpKind",toString:$estr}
	,PhpVar: {_hx_name:"PhpVar",_hx_index:2,__enum__:"phase.PhpKind",toString:$estr}
};
phase_PhpKind.__constructs__ = [phase_PhpKind.PhpType,phase_PhpKind.PhpFun,phase_PhpKind.PhpVar];
var phase_PhpScope = function(enclosing) {
	this.values = new haxe_ds_StringMap();
	this.enclosing = enclosing;
	this.depth = enclosing != null ? enclosing.depth + 1 : 0;
};
phase_PhpScope.__name__ = true;
phase_PhpScope.prototype = {
	getTop: function() {
		if(this.next != null) {
			return this.next.getTop();
		}
		return this;
	}
	,push: function() {
		if(this.next != null) {
			this.next.push();
		} else {
			this.next = new phase_PhpScope(this);
		}
	}
	,pop: function() {
		if(this.next != null && this.next.next != null) {
			return this.next.pop();
		}
		var scope = this.next;
		this.next = null;
		return scope;
	}
	,get: function(key) {
		var value = null;
		if(this.next != null) {
			value = this.next.get(key);
		}
		if(value == null) {
			return this.values.h[key];
		}
		return value;
	}
	,define: function(key,value) {
		if(this.next != null) {
			this.next.define(key,value);
			return;
		}
		this.values.h[key] = value;
	}
	,getAt: function(depth) {
		if(depth == this.depth) {
			return this;
		}
		if(this.next != null) {
			return this.next.getAt(depth);
		}
		return null;
	}
	,__class__: phase_PhpScope
};
var phase_Scanner = function(source,file,reporter) {
	this.source = source;
	this.file = file;
	this.reporter = reporter;
};
phase_Scanner.__name__ = true;
phase_Scanner.prototype = {
	scan: function() {
		this.tokens = [];
		this.start = 0;
		this.current = 0;
		this.line = 1;
		while(!this.isAtEnd()) {
			this.start = this.current;
			this.scanToken();
		}
		this.tokens.push(new phase_Token("[eof]","",null,{ line : this.line, offset : this.current, file : this.file}));
		return this.tokens;
	}
	,scanToken: function() {
		var c = this.advance();
		switch(c) {
		case "\t":case "\r":case " ":
			break;
		case "\n":
			this.newline();
			break;
		case "!":
			this.addToken(this.match("=") ? "!=" : "!");
			break;
		case "\"":
			this.string();
			break;
		case "#":
			this.addToken("#");
			break;
		case "&":
			this.addToken(this.match("&") ? "&&" : "&");
			break;
		case "'":
			this.string("'");
			break;
		case "(":
			this.addToken("(");
			break;
		case ")":
			this.addToken(")");
			break;
		case "*":
			this.addToken("*");
			break;
		case "+":
			if(this.match("=")) {
				this.addToken("+=");
			} else if(this.match("+")) {
				this.addToken(this.match("+") ? "+++" : "++");
			} else {
				this.addToken("+");
			}
			break;
		case ",":
			this.addToken(",");
			break;
		case "-":
			this.addToken(this.match("-") ? "--" : "-");
			break;
		case ".":
			this.addToken(this.match(".") ? "..." : ".");
			break;
		case "/":
			if(this.match("/")) {
				while(this.peek() != "\n" && !this.isAtEnd()) this.advance();
				if(this.peek() == "\n") {
					this.line++;
					this.advance();
				}
			} else {
				this.addToken("\\");
			}
			break;
		case ":":
			this.addToken(this.match(":") ? "::" : ":");
			break;
		case ";":
			this.addToken(";");
			break;
		case "<":
			this.addToken(this.match("=") ? "<=" : "<");
			break;
		case "=":
			this.addToken(this.match("=") ? "==" : "=");
			break;
		case ">":
			this.addToken(this.match("=") ? ">=" : ">");
			break;
		case "@":
			this.addToken("@");
			break;
		case "[":
			this.addToken("[");
			break;
		case "]":
			this.addToken("]");
			break;
		case "{":
			this.addToken("{");
			break;
		case "|":
			this.addToken(this.match("|") ? "||" : this.match(">") ? "|>" : "|");
			break;
		case "}":
			this.addToken("}");
			break;
		default:
			if(this.isDigit(c)) {
				this.number();
			} else if(this.isUcAlpha(c)) {
				this.typeIdentifier();
			} else if(this.isAlpha(c)) {
				this.identifier();
			} else {
				this.reporter.report({ line : this.line, offset : this.current, file : this.file},c,"Unexpected character: " + c);
			}
		}
	}
	,typeIdentifier: function() {
		while(this.isAlphaNumeric(this.peek())) this.advance();
		this.addToken("[type-identifier]");
	}
	,identifier: function() {
		while(this.isAlphaNumeric(this.peek())) this.advance();
		var text = this.source.substring(this.start,this.current);
		var type = phase_Scanner.keywords.h[text];
		if((this.peek() == "\"" || this.peek() == "'") && type == null) {
			type = "[template]";
		}
		if(type != null) {
			this.addToken(type);
		} else {
			this.addToken("[identifier]");
		}
	}
	,newline: function() {
		this.line++;
		while(this.peek() == "\n" && !this.isAtEnd()) {
			this.line++;
			this.advance();
		}
		this.addToken("[newline]");
	}
	,string: function(quote,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(quote == null) {
			quote = "\"";
		}
		while(this.peek() != quote && !this.isAtEnd()) {
			if(this.peek() == "\n") {
				this.line++;
			}
			if(this.peek() == "$" && this.peekNext() == "{") {
				this.addToken("[interpolation]",this.source.substring(this.start + 1,this.current));
				this.advance();
				this.advance();
				this.interpolatedString(quote,depth);
				return;
			}
			this.advance();
		}
		if(this.isAtEnd()) {
			this.reporter.report({ line : this.line, offset : this.current, file : this.file},"<EOF>","Unterminated string.");
			return;
		}
		this.advance();
		var value = this.source.substring(this.start + 1,this.current - 1);
		this.addToken("[string]",value);
	}
	,interpolatedString: function(quote,depth) {
		if(quote == null) {
			quote = "\"";
		}
		++depth;
		var brackets = 1;
		if(depth > 6) {
			this.reporter.report({ line : this.line, offset : this.current, file : this.file},"","Interpolation too deep: only 5 levels allowed");
		}
		while(brackets > 0 && !this.isAtEnd()) {
			this.start = this.current;
			this.scanToken();
			if(this.peek() == "{") {
				++brackets;
			}
			if(this.peek() == "}") {
				--brackets;
			}
		}
		this.start = this.current;
		--depth;
		this.string(quote,depth);
	}
	,number: function() {
		while(this.isDigit(this.peek())) this.advance();
		if(this.peek() == "." && this.isDigit(this.peekNext())) {
			this.advance();
			while(this.isDigit(this.peek())) this.advance();
		}
		this.addToken("[number]",parseFloat(this.source.substring(this.start,this.current)));
	}
	,isAtEnd: function() {
		return this.current >= this.source.length;
	}
	,isDigit: function(c) {
		if(c >= "0") {
			return c <= "9";
		} else {
			return false;
		}
	}
	,isUcAlpha: function(c) {
		if(c >= "A") {
			return c <= "Z";
		} else {
			return false;
		}
	}
	,isAlpha: function(c) {
		if(!(c >= "a" && c <= "z" || c >= "A" && c <= "Z")) {
			return c == "_";
		} else {
			return true;
		}
	}
	,isAlphaNumeric: function(c) {
		if(!this.isAlpha(c)) {
			return this.isDigit(c);
		} else {
			return true;
		}
	}
	,match: function(expected) {
		if(this.isAtEnd()) {
			return false;
		}
		if(this.source.charAt(this.current) != expected) {
			return false;
		}
		this.current++;
		return true;
	}
	,peek: function() {
		if(this.isAtEnd()) {
			return "";
		}
		return this.source.charAt(this.current);
	}
	,peekNext: function() {
		if(this.isAtEnd()) {
			return "";
		}
		return this.source.charAt(this.current + 1);
	}
	,advance: function() {
		this.current++;
		return this.source.charAt(this.current - 1);
	}
	,addToken: function(type,literal) {
		var text = this.source.substring(this.start,this.current);
		var pos = { line : this.line, offset : this.current, file : this.file};
		this.tokens.push(new phase_Token(type,text,literal,pos));
	}
	,__class__: phase_Scanner
};
var phase_Expression = function(expression) {
	this.expression = expression;
};
phase_Expression.__name__ = true;
phase_Expression.prototype = {
	accept: function(visitor) {
		return visitor.visitExpressionStmt(this);
	}
	,__class__: phase_Expression
};
var phase_UseTarget = $hxEnums["phase.UseTarget"] = { __ename__:true,__constructs__:null
	,TargetType: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"phase.UseTarget",toString:$estr}; },$_._hx_name="TargetType",$_.__params__ = ["name"],$_)
	,TargetFunction: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"phase.UseTarget",toString:$estr}; },$_._hx_name="TargetFunction",$_.__params__ = ["name"],$_)
};
phase_UseTarget.__constructs__ = [phase_UseTarget.TargetType,phase_UseTarget.TargetFunction];
var phase_UseKind = $hxEnums["phase.UseKind"] = { __ename__:true,__constructs__:null
	,UseNormal: {_hx_name:"UseNormal",_hx_index:0,__enum__:"phase.UseKind",toString:$estr}
	,UseAlias: ($_=function(alias) { return {_hx_index:1,alias:alias,__enum__:"phase.UseKind",toString:$estr}; },$_._hx_name="UseAlias",$_.__params__ = ["alias"],$_)
	,UseSub: ($_=function(items) { return {_hx_index:2,items:items,__enum__:"phase.UseKind",toString:$estr}; },$_._hx_name="UseSub",$_.__params__ = ["items"],$_)
};
phase_UseKind.__constructs__ = [phase_UseKind.UseNormal,phase_UseKind.UseAlias,phase_UseKind.UseSub];
var phase_Use = function(path,absolute,kind,attribute) {
	this.path = path;
	this.absolute = absolute;
	this.kind = kind;
	this.attribute = attribute;
};
phase_Use.__name__ = true;
phase_Use.prototype = {
	accept: function(visitor) {
		return visitor.visitUseStmt(this);
	}
	,__class__: phase_Use
};
var phase_Namespace = function(path,decls,attribute) {
	this.path = path;
	this.decls = decls;
	this.attribute = attribute;
};
phase_Namespace.__name__ = true;
phase_Namespace.prototype = {
	accept: function(visitor) {
		return visitor.visitNamespaceStmt(this);
	}
	,__class__: phase_Namespace
};
var phase_Var = function(name,initializer) {
	this.name = name;
	this.initializer = initializer;
};
phase_Var.__name__ = true;
phase_Var.prototype = {
	accept: function(visitor) {
		return visitor.visitVarStmt(this);
	}
	,__class__: phase_Var
};
var phase_Global = function(name) {
	this.name = name;
};
phase_Global.__name__ = true;
phase_Global.prototype = {
	accept: function(visitor) {
		return visitor.visitGlobalStmt(this);
	}
	,__class__: phase_Global
};
var phase_Throw = function(keyword,expr) {
	this.keyword = keyword;
	this.expr = expr;
};
phase_Throw.__name__ = true;
phase_Throw.prototype = {
	accept: function(visitor) {
		return visitor.visitThrowStmt(this);
	}
	,__class__: phase_Throw
};
var phase_Try = function(body,catches) {
	this.body = body;
	this.catches = catches;
};
phase_Try.__name__ = true;
phase_Try.prototype = {
	accept: function(visitor) {
		return visitor.visitTryStmt(this);
	}
	,__class__: phase_Try
};
var phase_While = function(condition,body) {
	this.condition = condition;
	this.body = body;
};
phase_While.__name__ = true;
phase_While.prototype = {
	accept: function(visitor) {
		return visitor.visitWhileStmt(this);
	}
	,__class__: phase_While
};
var phase_For = function(key,value,target,body) {
	this.key = key;
	this.value = value;
	this.target = target;
	this.body = body;
};
phase_For.__name__ = true;
phase_For.prototype = {
	accept: function(visitor) {
		return visitor.visitForStmt(this);
	}
	,__class__: phase_For
};
var phase_If = function(condition,thenBranch,elseBranch) {
	this.condition = condition;
	this.thenBranch = thenBranch;
	this.elseBranch = elseBranch;
};
phase_If.__name__ = true;
phase_If.prototype = {
	accept: function(visitor) {
		return visitor.visitIfStmt(this);
	}
	,__class__: phase_If
};
var phase_Switch = function(target,cases) {
	this.target = target;
	this.cases = cases;
};
phase_Switch.__name__ = true;
phase_Switch.prototype = {
	accept: function(visitor) {
		return visitor.visitSwitchStmt(this);
	}
	,__class__: phase_Switch
};
var phase_Block = function(statements) {
	this.statements = statements;
};
phase_Block.__name__ = true;
phase_Block.prototype = {
	accept: function(visitor) {
		return visitor.visitBlockStmt(this);
	}
	,__class__: phase_Block
};
var phase_Function = function(name,params,body,ret,attribute) {
	this.name = name;
	this.params = params;
	this.body = body;
	this.ret = ret;
	this.attribute = attribute;
};
phase_Function.__name__ = true;
phase_Function.prototype = {
	accept: function(visitor) {
		return visitor.visitFunctionStmt(this);
	}
	,__class__: phase_Function
};
var phase_Return = function(keyword,value) {
	this.keyword = keyword;
	this.value = value;
};
phase_Return.__name__ = true;
phase_Return.prototype = {
	accept: function(visitor) {
		return visitor.visitReturnStmt(this);
	}
	,__class__: phase_Return
};
var phase_FieldKind = $hxEnums["phase.FieldKind"] = { __ename__:true,__constructs__:null
	,FUse: ($_=function(type) { return {_hx_index:0,type:type,__enum__:"phase.FieldKind",toString:$estr}; },$_._hx_name="FUse",$_.__params__ = ["type"],$_)
	,FVar: ($_=function(v,type) { return {_hx_index:1,v:v,type:type,__enum__:"phase.FieldKind",toString:$estr}; },$_._hx_name="FVar",$_.__params__ = ["v","type"],$_)
	,FProp: ($_=function(getter,setter,type) { return {_hx_index:2,getter:getter,setter:setter,type:type,__enum__:"phase.FieldKind",toString:$estr}; },$_._hx_name="FProp",$_.__params__ = ["getter","setter","type"],$_)
	,FFun: ($_=function(fun) { return {_hx_index:3,fun:fun,__enum__:"phase.FieldKind",toString:$estr}; },$_._hx_name="FFun",$_.__params__ = ["fun"],$_)
};
phase_FieldKind.__constructs__ = [phase_FieldKind.FUse,phase_FieldKind.FVar,phase_FieldKind.FProp,phase_FieldKind.FFun];
var phase_FieldAccess = $hxEnums["phase.FieldAccess"] = { __ename__:true,__constructs__:null
	,AStatic: {_hx_name:"AStatic",_hx_index:0,__enum__:"phase.FieldAccess",toString:$estr}
	,APublic: {_hx_name:"APublic",_hx_index:1,__enum__:"phase.FieldAccess",toString:$estr}
	,APrivate: {_hx_name:"APrivate",_hx_index:2,__enum__:"phase.FieldAccess",toString:$estr}
	,AAbstract: {_hx_name:"AAbstract",_hx_index:3,__enum__:"phase.FieldAccess",toString:$estr}
	,AConst: {_hx_name:"AConst",_hx_index:4,__enum__:"phase.FieldAccess",toString:$estr}
};
phase_FieldAccess.__constructs__ = [phase_FieldAccess.AStatic,phase_FieldAccess.APublic,phase_FieldAccess.APrivate,phase_FieldAccess.AAbstract,phase_FieldAccess.AConst];
var phase_Field = function(name,kind,access,attribute) {
	this.name = name;
	this.kind = kind;
	this.access = access;
	this.attribute = attribute;
};
phase_Field.__name__ = true;
phase_Field.prototype = {
	accept: function(visitor) {
		return visitor.visitFieldStmt(this);
	}
	,__class__: phase_Field
};
var phase_ClassKind = $hxEnums["phase.ClassKind"] = { __ename__:true,__constructs__:null
	,KindClass: {_hx_name:"KindClass",_hx_index:0,__enum__:"phase.ClassKind",toString:$estr}
	,KindInterface: {_hx_name:"KindInterface",_hx_index:1,__enum__:"phase.ClassKind",toString:$estr}
	,KindTrait: {_hx_name:"KindTrait",_hx_index:2,__enum__:"phase.ClassKind",toString:$estr}
};
phase_ClassKind.__constructs__ = [phase_ClassKind.KindClass,phase_ClassKind.KindInterface,phase_ClassKind.KindTrait];
var phase_Class = function(name,kind,superclass,interfaces,fields,attribute) {
	this.name = name;
	this.kind = kind;
	this.superclass = superclass;
	this.interfaces = interfaces;
	this.fields = fields;
	this.attribute = attribute;
};
phase_Class.__name__ = true;
phase_Class.prototype = {
	accept: function(visitor) {
		return visitor.visitClassStmt(this);
	}
	,__class__: phase_Class
};
var phase_Token = function(type,lexeme,literal,pos) {
	this.type = type;
	this.lexeme = lexeme;
	this.literal = literal;
	this.pos = pos;
};
phase_Token.__name__ = true;
phase_Token.prototype = {
	__class__: phase_Token
};
var phase_VisualErrorReporter = function(source) {
	this.errorsReported = 0;
	this.source = source;
};
phase_VisualErrorReporter.__name__ = true;
phase_VisualErrorReporter.prototype = {
	hadError: function() {
		return this.errorsReported > 0;
	}
	,report: function(pos,where,message) {
		this.errorsReported++;
		var lines = this.source.split("\n");
		var limit = lines.length > 5 ? 5 : lines.length;
		var line = pos.line;
		var start = this.source.substring(0,pos.offset).split("\n")[line - 1].length - where.length;
		var end = where.length;
		var out = ["","ERROR: " + pos.file + " [line " + pos.line + " column " + start + "]:",""];
		var curLine = line - 3;
		if(curLine < 0) {
			curLine = 0;
		}
		while(true) {
			out.push(this.formatLine(curLine) + lines[curLine]);
			++curLine;
			if(!(curLine < line)) {
				break;
			}
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = start;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(" ");
		}
		var spaces = "      | " + _g.join("");
		var _g = [];
		var _g1 = 0;
		var _g2 = end;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push("^");
		}
		var markers = spaces + _g.join("");
		out.push(markers);
		out.push(spaces + message);
		while(true) {
			var content = lines[curLine];
			if(content == null) {
				content = "";
			}
			out.push(this.formatLine(curLine) + content);
			++curLine;
			if(!(curLine < limit)) {
				break;
			}
		}
		out.push("");
		var v = out.join("\n");
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
	}
	,formatLine: function(curLine) {
		var line = Std.string(curLine + 1);
		if(line.length == 1) {
			return "    " + line + " | ";
		}
		if(line.length == 2) {
			return "   " + line + " | ";
		}
		if(line.length == 3) {
			return "  " + line + " | ";
		}
		if(line.length == 4) {
			return " " + line + " | ";
		}
		return "" + line + " | ";
	}
	,__class__: phase_VisualErrorReporter
};
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _g ) {
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( _g ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( _g ) {
		var e = haxe_Exception.caught(_g).unwrap();
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _g1 ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
	,__class__: sys_io_FileInput
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,__class__: sys_io_FileOutput
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__:true,__constructs__:null
	,SeekBegin: {_hx_name:"SeekBegin",_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_name:"SeekCur",_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_name:"SeekEnd",_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
sys_io_FileSeek.__constructs__ = [sys_io_FileSeek.SeekBegin,sys_io_FileSeek.SeekCur,sys_io_FileSeek.SeekEnd];
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
phase_NodeCompiler.extensions = ["phs","phase"];
phase_Parser.continuationTokens = [".","+","+++","|>","-","==","!=","&&","||"];
phase_PhpGenerator.typeAliases = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["String"] = "string";
	_g.h["Int"] = "int";
	_g.h["Array"] = "array";
	_g.h["Callable"] = "callable";
	_g.h["Any"] = "mixed";
	_g.h["Scalar"] = "scalar";
	$r = _g;
	return $r;
}(this));
phase_Scanner.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["class"] = "class";
	_g.h["interface"] = "interface";
	_g.h["trait"] = "trait";
	_g.h["enum"] = "enum";
	_g.h["extends"] = "extends";
	_g.h["implements"] = "implements";
	_g.h["enum"] = "enum";
	_g.h["static"] = "static";
	_g.h["private"] = "private";
	_g.h["public"] = "public";
	_g.h["abstract"] = "abstract";
	_g.h["const"] = "const";
	_g.h["false"] = "false";
	_g.h["true"] = "true";
	_g.h["else"] = "else";
	_g.h["function"] = "function";
	_g.h["for"] = "for";
	_g.h["if"] = "if";
	_g.h["null"] = "null";
	_g.h["return"] = "return";
	_g.h["super"] = "super";
	_g.h["this"] = "this";
	_g.h["var"] = "var";
	_g.h["global"] = "global";
	_g.h["while"] = "while";
	_g.h["use"] = "use";
	_g.h["namespace"] = "namespace";
	_g.h["as"] = "as";
	_g.h["in"] = "in";
	_g.h["is"] = "is";
	_g.h["throw"] = "throw";
	_g.h["try"] = "try";
	_g.h["catch"] = "catch";
	_g.h["switch"] = "switch";
	_g.h["case"] = "case";
	_g.h["default"] = "default";
	$r = _g;
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
