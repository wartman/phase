namespace Phase

use Phase::Language::{
  Token,
  TokenType,
  Position,
  Expr,
  ExprDef,
  Literal,
  Stmt,
  StmtDef,
  UseKind,
  UseTarget,
  TypePath,
  CallArgument,
  FunctionArg,
  FunctionDecl,
  Field,
  FieldAccess,
  FieldKind,
  ClassDecl,
  ClassKind,
  MatchCase
}

class Parser {
  static continuationTokens: Array<String> = [
    TokenType.TokDot,
    TokenType.TokPlus,
    TokenType.TokConcat,
    TokenType.TokPipe,
    TokenType.TokMinus,
    TokenType.TokBoolEqual,
    TokenType.TokBangEqual,
    TokenType.TokBoolAnd,
    TokenType.TokBoolOr
  ]

  private tokens: Array<Token>
  private reporter: ErrorReporter
  private current: Int
  private uid: Int = 0
  private inNamespace: Bool = false

  new(
    this.tokens: Array<Token>,
    this.reporter: ErrorReporter
  ) {}

  parse(): Array<Stmt> {
    var statements = []
    
    this.current = 0

    this.ignoreNewlines()
    while (!this.isAtEnd()) {
      var stmt: Stmt = this.declaration()
      if (stmt != null) statements.push(stmt)
    }

    return statements
  }

  declaration(attributes: ?Array<Expr> = null): Stmt {
    if (attributes == null) {
      attributes = []
    }
    if (this.matches([ TokenType.TokLeftBracket ])) {
      return this.declaration(this.attributeList())
    }
    if (this.matches([ TokenType.TokVar ])) {
      if (attributes.length > 0) {
        throw this.error(this.previous(), 'Attributes are not allowed here')
      }
      return this.varDeclaration()
    }
    if (this.matches([ TokenType.TokGlobal ])) {
      if (attributes.length > 0) {
        throw this.error(this.previous(), 'Attributes are not allowed here')
      }
      return this.globalDeclaration()
    }
    if (this.matches([ TokenType.TokNamespace ])) {
      return this.namespaceDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokUse ])) {
      return this.useDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokFunction ])) {
      return this.functionDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokClass ])) {
      return this.classDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokInterface ])) {
      return this.interfaceDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokTrait ])) {
      return this.traitDeclaration(attributes)
    }
    if (this.matches([ TokenType.TokEnum ])) {
      return this.enumDeclaration(attributes)
    }

    return this.statement()
  }

  statement(): Stmt {
    if (this.matches([ TokenType.TokVar ])) return this.varDeclaration()
    if (this.matches([ TokenType.TokGlobal ])) return this.globalDeclaration()
    if (this.matches([ TokenType.TokIf ])) return this.ifStatement()
    if (this.matches([ TokenType.TokReturn ])) return this.returnStatement()
    if (this.matches([ TokenType.TokWhile ])) return this.whileStatement()
    if (this.matches([ TokenType.TokDo ])) return this.doStatement()
    if (this.matches([ TokenType.TokFor ])) return this.forStatement()
    if (this.matches([ TokenType.TokSwitch ])) return this.switchStatement()
    if (this.matches([ TokenType.TokThrow ])) return this.throwStatement()
    if (this.matches([ TokenType.TokTry ])) return this.tryStatement()
    if (this.matches([ TokenType.TokLeftBrace ])) return this.blockStatement()
    return this.expressionStatement()
  }

  private namespaceDeclaration(attributes: Array<Expr>): Stmt {
    if (this.inNamespace) {
      throw this.error(this.previous(), 'Namespaces cannot be nested')
    }
    this.inNamespace = true

    var start = this.previous()
    // Note: we don't use `this.parseTypePath()` here as namespaces
    //       cannot start with `::` and can't have parameters.
    var parts = this.parseList(TokenType.TokScopeResolutionOperator) {
      return this
        .consume(TokenType.TokTypeIdentifier, "Expect a package name seperated by '::'")
        .lexeme
    }
    var name = parts.pop()
    var path: TypePath = TypePath(
      ns: parts,
      name: name,
      params: []
    )
    
    if (this.matches([ TokenType.TokLeftBrace ])) {
      this.ignoreNewlines()

      var decls: Array<Stmt> = []

      while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
        decls.push(this.declaration())
      }

      this.consume(TokenType.TokRightBrace, "Expect '}' at the end of a package declaration.")
      this.ignoreNewlines()

      this.inNamespace = false
      return Stmt(
        stmt: StmtDef.SNamespace(
          path: path,
          decls: decls,
          attributes: attributes
        ),
        pos: start.pos.merge(this.previous().pos)
      )
    }

    // Parse the rest of the file as a single namespace.
    this.expectEndOfStatement()

    var decls: Array<Stmt> = []
    while (!this.isAtEnd()) {
      decls.push(this.declaration())
    }
    this.ignoreNewlines()
    return Stmt(
      stmt: StmtDef.SNamespace(
        path: path,
        decls: decls,
        attributes: attributes
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private useDeclaration(attributes: Array<Expr>): Stmt {
    if (!this.inNamespace) {
      throw this.error(this.previous(), '`use` is not allowed outside a namespace')
    }
    
    var start = this.previous()
    var kind: UseKind = UseKind.UseNormal()
    var absolute = false
    var path: Array<String> = []
    
    if (this.matches([ TokenType.TokScopeResolutionOperator ])) {
      absolute = true
    }

    do {
      this.ignoreNewlines()
      if (this.matches([ TokenType.TokTypeIdentifier ])) {
        path.push(this.previous().lexeme)
      } else if (this.matches([ TokenType.TokIdentifier ])) {
        // Is a function -- only allowed at the end.
        kind = UseKind.UseSub([ UseTarget.TargetFunction(this.previous().lexeme) ])
        if (this.matches([ TokenType.TokScopeResolutionOperator ])) {
          throw this.error(previous(), "Lowercase identifiers may only come at the end of a use statement.");
        }
        break
      } else if (this.matches([ TokenType.TokLeftBrace ])) {
        kind = UseKind.UseSub(this.parseList(TokenType.TokComma) {
          if (this.matches([ TokenType.TokTypeIdentifier, TokenType.TokIdentifier ])) {
            var tok = this.previous()
            return if (tok.type == TokenType.TokIdentifier) UseTarget.TargetFunction(tok.lexeme) else UseTarget.TargetType(tok.lexeme)
          } else {
            throw this.error(this.peek(), "Expect an identifier or a type identifier")
            return null
          }
        })
        this.ignoreNewlines()
        this.consume(TokenType.TokRightBrace, "Expect a '}'.")
        break
      } else {
        throw this.error(this.previous(), "Expected a type identifier or a '{'")
      }
    } while (this.matches([ TokenType.TokScopeResolutionOperator ]) && !this.isAtEnd())

    if (this.matches([ TokenType.TokAs ])) {
      if (this.matches([ TokenType.TokTypeIdentifier, TokenType.TokIdentifier ])) {
        var tok = this.previous()

        match (kind) {
          UseSub(items) -> if (items.length == 1 && items[0].tag == 'TargetFunction') {
            var p = items[0].params[0]
            path.push(p)
          }
          default -> null
        }

        kind = UseKind.UseAlias(
          if (tok.type == TokIdentifier)
            UseTarget.TargetFunction(tok.lexeme)
            else UseTarget.TargetType(tok.lexeme)
        )
      } else {
        throw this.error(this.peek(), "Expect an identifier or a type identifier");
      }
    }

    this.expectEndOfStatement()

    return Stmt(
      stmt: StmtDef.SUse(
        path: path,
        kind: kind, 
        attributes: attributes
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private varDeclaration() {
    var start = this.previous()
    var name: Token = this.consume(TokenType.TokIdentifier, "Expect a variable name")
    var type: TypePath = null
    var init: Expr = null

    if (this.matches([ TokenType.TokColon ])) {
      type = this.parseTypePath()
    }
    if (this.matches([ TokenType.TokEqual ])) {
      init = this.expression()
    }

    this.expectEndOfStatement()

    return Stmt(
      stmt: StmtDef.SVar(
        name: name.lexeme,
        type: type,
        initializer: init
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private globalDeclaration(): Stmt {
    var name: Token = this.consume(TokenType.TokIdentifier, 'Expect a variable name')
    this.expectEndOfStatement()
    return Stmt(
      stmt: StmtDef.SGlobal(name.lexeme),
      pos: name.pos
    )
  }

  private functionDecl(isAnnon: Bool, attributes: Array<Expr>): FunctionDecl {
    if (attributes == null) {
      attributes = []
    }

    var start = this.previous()
    var name: Token = if (!isAnnon || this.check(TokenType.TokIdentifier))
      this.consume(TokenType.TokIdentifier, 'Expect a function name').lexeme
    else ''

    this.consume(TokenType.TokLeftParen, "Expect '(' after function name.")
    var args = this.functionArgs()
    var ret: TypePath = null;
    if (this.matches([ TokenType.TokColon ])) {
      ret = this.parseTypePath()
    }
    this.consume(TokenType.TokLeftBrace, "Expect '{' before function body")
    var body = this.functionBody()

    return FunctionDecl(
      name: name,
      args: args,
      body: body,
      ret: ret,
      attributes: attributes
    )
  }

  private functionArgs(allowInit: Bool = false): Array<FunctionArg> {
    var args: Array<FunctionArg> = []
    if (!this.check(TokenType.TokRightParen)) {
      do {
        this.ignoreNewlines()
        
        var isInit = false

        if (allowInit && this.matches([ TokenType.TokThis ])) {
          isInit = true
          this.consume(TokenType.TokDot, "Expect a '.' after 'this'.")
        }

        var name = this.consume(TokenType.TokIdentifier, 'Expect parameter name')
        var type = null
        var expr:Expr = null

        if (this.matches([ TokenType.TokColon ])) {
          type = this.parseTypePath()
        }
        if (this.matches([ TokenType.TokEqual ])) {
          expr = this.expression()
        }

        args.push(FunctionArg(
          name: name.lexeme,
          type: type,
          expr: expr,
          isInit: isInit
        ))
      } while(this.matches([ TokenType.TokComma ]))
    }
    this.ignoreNewlines()
    this.consume(TokenType.TokRightParen, "Expect ')' after parameters")
    return args
  }

  private functionBody():Stmt {
    var start = this.previous()
    var body:Array<Stmt> = null
    
    if (this.matches([ TokenType.TokRightBrace ])) {
      return Stmt(
        stmt: StmtDef.SBlock([]),
        pos: start.pos
      )
    }

    if (!this.check(TokenType.TokNewline) && !this.check(TokenType.TokReturn)) {
      // Treat the next expression as a return.
      body = [ Stmt(
        stmt: StmtDef.SReturn(this.expression()),
        pos: start.pos.merge(this.previous().pos)
      ) ]
      this.ignoreNewlines()
      this.consume(TokenType.TokRightBrace, 'Inline functions must contain only one expression.')
    } else {
      body = this.block()
    }
    
    return Stmt(
      stmt: StmtDef.SBlock(body),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private functionDeclaration(attributes: Array<Expr>): Stmt {
    var start = this.previous()
    var def = this.functionDecl(false, attributes)
    this.ignoreNewlines()
    return Stmt(
      stmt: StmtDef.SFunction(def),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private parseTypeParams(): Array<TypePath> {
    var params: Array<TypePath> = []
    if (this.matches([ TokenType.TokLess ])) {
      this.ignoreNewlines()
      params = this.parseList(TokenType.TokComma) {
        this.ignoreNewlines()
        return this.parseTypePath()
      }
      this.ignoreNewlines()
      this.consume(TokenType.TokGreater, "Expect a '>' at the end of type parameter list")
    }
    return params
  }

  private classDeclaration(attributes: Array<Expr>): Stmt {
    var start: Token = this.previous()
    var name: Token = this.consume(TokenType.TokTypeIdentifier, "Expect a class name. Must start with an uppercase letter.")
    var params = this.parseTypeParams()
    var superclass: ?TypePath = null
    var interfaces: Array<TypePath> = []
    var fields: Array<Field> = []

    this.ignoreNewlines()

    while (this.matches([
      TokenType.TokExtends,
      TokenType.TokImplements
    ]) && !this.isAtEnd()) {
      var op: Token = this.previous()
      if (op == TokenType.TokExtends) {
        if (superclass != null) {
          throw this.error(op, 'Can only extend once')
        }
        superclass = this.parseTypePath(false)
      } else {
        interfaces.push(this.parseTypePath(false))
      }
      this.ignoreNewlines()
    }

    this.consume(TokenType.TokLeftBrace, "Expect '{' before class body.")
    this.ignoreNewlines()

    while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
      this.ignoreNewlines()

      var field: Field = this.fieldDeclaration()
      var kind: FieldKind = field.kind

      match (kind) {
        FFun(func) -> for (a in func.args) {
          if (
            a.isInit == true
            && ! (fields[a.name] |> isset())
          ) {
            fields.push(Field(
              name: a.name,
              kind: FieldKind.FVar(
                name: a.name,
                type: a.type,
                initializer: null
              ),
              type: a.type,
              access: [ FieldAccess.APublic ],
              attributes: [],
              pos: this.previous().pos
            ))
          }
        }
        default -> null
      }

      fields.push(field);
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect '}' at end of class body")
    this.ignoreNewlines()

    return Stmt(
      stmt: StmtDef.SClass(ClassDecl(
        name: name.lexeme,
        kind: ClassKind.KindClass,
        superclass: superclass,
        interfaces: interfaces,
        params: params,
        fields: fields,
        attributes: attributes
      )),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private interfaceDeclaration(attributes: Array<Expr>): Stmt {
    var start = this.previous()
    var name = this.consume(TokenType.TokTypeIdentifier, 'Expect a class name. Must start uppercase.')
    var params = this.parseTypeParams()
    var interfaces: Array<TypePath> = []
    var fields: Array<Field> = []

    this.ignoreNewlines()
    while (this.matches([ TokenType.TokExtends ]) && !this.isAtEnd()) {
      interfaces.push(this.parseTypePath(false))
      this.ignoreNewlines()
    }

    this.consume(TokenType.TokLeftBrace, "Expect '{' before interface body.");
    this.ignoreNewlines()
    
    while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
      this.ignoreNewlines()
      var field = this.fieldDeclaration()
      if (!field.access.contains(FieldAccess.AAbstract)) {
        field.access.push(FieldAccess.AAbstract)
      }
      fields.push(field)
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect '}' at end of interface body");
    this.ignoreNewlines()
    
    return Stmt(
      stmt: StmtDef.SClass(ClassDecl(
        name: name.lexeme,
        kind: ClassKind.KindInterface,
        params: params,
        superclass: null,
        interfaces: interfaces,
        fields: fields,
        attributes: attributes
      )),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private traitDeclaration(attributes: Array<Expr>): Stmt {
    var start = this.previous()
    var name = this.consume(TokenType.TokTypeIdentifier, 'Expect a trait name. Must start uppercase.')
    var params = this.parseTypeParams()
    var fields: Array<Field> = []

    this.consume(TokenType.TokLeftBrace, "Expect '{' before trait body.")
    this.ignoreNewlines()
    
    while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
      this.ignoreNewlines()
      fields.push(this.fieldDeclaration())
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect '}' at end of trait body")
    this.ignoreNewlines()

    return Stmt(
      stmt: StmtDef.SClass(ClassDecl(
        name: name.lexeme,
        kind: ClassKind.KindTrait,
        params: params,
        superclass: null,
        interfaces: [],
        fields: fields,
        attributes: attributes
      )),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private enumDeclaration(attributes: Array<Expr>): Stmt {
    var start = this.previous()
    var enumName = this.consume(TokenType.TokTypeIdentifier, 'Expect an enum name. Must start uppercase.')
    var params = this.parseTypeParams()
    var fields: Array<Field> = []

    if (this.matches([ TokenType.TokAs ])) {
      var superClass = this.consume(TokenType.TokTypeIdentifier, 'Expect a wrapped type name')
  
      this.consume(TokenType.TokLeftBrace, "Expect '{' before enum body.")
      this.ignoreNewlines()
      
      var index = 0
      while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
        this.ignoreNewlines()
        var fieldName = this.consume(TokenType.TokTypeIdentifier, "Expect an uppercase identifier")
        var value: ?Expr = null 
        
        if (this.matches([ TokenType.TokEqual ])) {
          value = this.expression()
        } else {
          switch (superClass.lexeme) {
            case 'String': 
              value = Expr(expr: ExprDef.ELiteral(LString(fieldName.lexeme)), pos: fieldName.pos)
            case 'Int': 
              value = Expr(expr: ExprDef.ELiteral(LNumber(index)), pos: fieldName.pos)
            case _: 
              throw this.error(superClass, 'Unknown type -- currently enums may only be Strings or Ints')
          }
        }

        index++
        this.expectEndOfStatement()
        fields.push(Field(
          name: fieldName.lexeme,
          type: null,
          kind: FieldKind.FVar(fieldName.lexeme, null, value, null),
          access: [ FieldAccess.AConst ],
          attributes: []
        ))
      }
  
      this.ignoreNewlines()
      this.consume(TokenType.TokRightBrace, "Expect '}' at end of enum body")
      this.ignoreNewlines()
    
      return Stmt(
        stmt: StmtDef.SClass(ClassDecl(
          name: enumName.lexeme,
          params: params,
          kind: ClassKind.KindClass,
          superclass: null,
          interfaces: [],
          fields: fields,
          attributes: attributes
        )),
        pos: start.pos.merge(this.previous().pos)
      )
    }

    this.consume(TokenType.TokLeftBrace, "Expect '{' before enum body.")
    this.ignoreNewlines()
    var index = 0

    while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
      this.ignoreNewlines()
      var name = this.consume(TokenType.TokTypeIdentifier, 'Expect an uppercase identifier')
      var params:Array<FunctionArg> = []
      var ret: TypePath = TypePath(
        ns: [],
        name: enumName.lexeme,
        params: [],
        isAbsolute: false,
        isNullable: false
      )

      if (!this.check(TokenType.TokNewline)) {
        this.consume(TokenType.TokLeftParen, "Expect '(' after function name.")
        params = this.functionArgs(false)
      }

      var body = CodeGenerator.generateStmt('{ return ${enumName.lexeme}(
        ${index++},
        "${name.lexeme}",
        [ ${params.map { it.name.lexeme }.join(', ')} ]
      ) }', enumName.pos, reporter)

      this.expectEndOfStatement()

      fields.push(Field(
        name: name.lexeme,
        type: ret,
        kind: FieldKind.FFun(FunctionDecl(name, params, body, ret, [])),
        access: [ FieldAccess.APublic, FieldAccess.AStatic ],
        attributes: []
      ))
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect '}' at end of enum body")
    this.ignoreNewlines()

    return Stmt(
      stmt: StmtDef.SClass(ClassDecl(
        name: enumName.lexeme,
        kind: ClassKind.KindClass,
        params: params,
        superclass: TypePath(
          ns: [ 'Std' ],
          name: 'PhaseEnum',
          params: [],
          isAbsolute: true,
          isNullable: false
        ),
        interfaces: [],
        fields: fields,
        attributes: attributes
      )),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private fieldDeclaration(): Field {
    var start = this.previous()
    if (this.matches([ TokenType.TokUse ])) {
      // Note: this will need to get more complex later.
      var out = Field(
        name: '',
        kind: FieldKind.FUse(
          path: this.parseTypePath(false)
        ),
        access: [],
        attributes: [],
        pos: start.pos.merge(this.previous().pos)
      )
      this.expectEndOfStatement()
      return out
    }

    if (this.matches([ TokenType.TokConst ])) {
      var name = this.consume(TokenType.TokTypeIdentifier, 'Expect uppercase identifier')
      var type: Type = null
      if (this.matches([ TokenType.TokColon ])) {
        type = this.parseTypePath()
      }
      this.consume(TokenType.TokEqual, 'Expect assignment for consts')
      this.ignoreNewlines()
      var value = this.expression()
      var out = Field(
        name: name.lexeme,
        kind: FieldKind.FVar(
          name: name.lexeme,
          type: type,
          initializer: value
        ),
        access: [ AConst ],
        attributes: [],
        pos: start.pos.merge(this.previous().pos)
      );
      this.expectEndOfStatement()
      return out
    }

    var access: Array<FieldAccess> = []
    var attributes: Array<Expr> = []
    var addAccess = {
      if (access.contains(it)) {
        throw this.error(this.previous(), 'Only one ${it} declaration is allowed per field')
      }
      access.push(it)
    }

    if (this.matches([ TokenType.TokLeftBracket ])) {
      attributes = this.attributeList()
    }

    while (this.matches([
      TokenType.TokStatic,
      TokenType.TokPublic,
      TokenType.TokPrivate,
      TokenType.TokAbstract
    ]) && !this.isAtEnd()) {
      switch (this.previous().type) {
        case TokenType.TokStatic: addAccess(FieldAccess.AStatic)
        case TokenType.TokPrivate: addAccess(FieldAccess.APrivate)
        case TokenType.TokPublic: addAccess(FieldAccess.APublic)
        case TokenType.TokAbstract: addAccess(FieldAccess.AAbstract)
        default:
      }
    }

    if (!access.contains(FieldAccess.APublic) && !access.contains(FieldAccess.APrivate)) {
      addAccess(FieldAccess.APublic)
    }

    var name: Token = this.consume(TokenType.TokIdentifier, 'Expected an identifier')
    var type: TypePath = null

    if (this.matches([ TokenType.TokColon ])) {
      type = this.parseTypePath()
    }

    if (this.matches([ TokenType.TokNewline ])) {
      this.ignoreNewlines()
      return Field(
        name: name.lexeme,
        type: type,
        access: access,
        kind: FieldKind.FVar(
          name: name.lexeme,
          type: type,
          initializer: null
        ),
        attributes: attributes,
        pos: start.pos.merge(this.previous().pos)
      )
    }

    if (this.matches([ TokenType.TokLeftBrace ])) {
      var getter: ?FunctionDecl = null
      var setter: ?FunctionDecl = null
      while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
        this.ignoreNewlines()
        var mode: Token = this.consume(TokenType.TokIdentifier, "Expect an identifier");
        switch (mode.lexeme) {
          case 'get':
            if (getter != null) {
              throw this.error(mode, '`get` already defined')
            }
            
            this.consume(TokenType.TokLeftBrace, "Expect a '{'")

            var body = this.functionBody()
            
            this.expectEndOfStatement()
            getter = FunctionDecl(
              name: mode.lexeme,
              args: [],
              body: body,
              ret: type,
              attributes: []
            )
          case 'set':
            if (setter != null) {
              throw this.error(mode, '`set` already defined')
            }
            this.consume(TokenType.TokLeftBrace, "Expect a '{'")
            var body = this.functionBody()
            this.expectEndOfStatement()
            setter = FunctionDecl(
              name: mode.lexeme,
              args: [
                FunctionArg(
                  name: 'value',
                  type: type,
                  expr: null
                )
              ],
              body: body,
              ret: type,
              attributes: []
            )
          default:
            throw this.error(mode, 'Expected `get` or `set`')
        }
      }
      this.ignoreNewlines()
      this.consume(TokenType.TokRightBrace, 'Expected a `}`')
      return Field(
        name: name.lexeme,
        type: type,
        access: access,
        kind: FieldKind.FProp(
          getter: getter,
          setter: setter,
          type: type
        ),
        attributes: attributes,
        pos: start.pos.merge(this.previous().pos)
      )
    }

    if (this.matches([ TokenType.TokEqual ])) {
      if (access.contains(FieldAccess.AAbstract)) {
        throw this.error(this.previous(), 'No assignment allowed')
      }

      this.ignoreNewlines()
      var expr = this.expression()
      this.expectEndOfStatement()
      return Field(
        name: name.lexeme,
        type: type,
        access: access,
        kind: FieldKind.FVar(
          name: name.lexeme,
          type: type,
          initializer: expr
        ),
        attributes: attributes,
        pos: start.pos.merge(this.previous().pos)
      )
    }

    this.consume(TokenType.TokLeftParen, "Expect '(' after function name.")
    var args = this.functionArgs(name.lexeme == 'new');
    var type: ?TypePath = null
    var body:Stmt = null;
    
    if (this.matches([ TokenType.TokColon])) {
      type = this.parseTypePath()
    }

    if (access.contains(FieldAccess.AAbstract)) {
      this.expectEndOfStatement()
    } else {
      this.consume(TokenType.TokLeftBrace, "Expect '{' before function body")
      body = this.functionBody()
      this.expectEndOfStatement()
    }

    return Field(
      name: name.lexeme,
      access: access,
      type: type,
      kind: FieldKind.FFun(FunctionDecl(
        name: name.lexeme,
        args: args,
        body: body,
        ret: type,
        attributes: []
      )),
      attributes: attributes,
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private attributeList(): Array<Expr> {
    var attributes: Array<Expr> = []
    var start = this.previous()

    do {
      var path: TypePath = this.parseList(TokenType.TokScopeResolutionOperator) {
        return this.consume(TokenType.TokTypeIdentifier, "Expect a package name seperated by '::'")
      }
      var args: Array<CallArgument> = []
      if (this.matches([ TokenType.TokLeftParen ])) {
        if (!this.matches([ TokenType.TokRightParen ])) {
          args = this.parseArguments()
        }
        this.ignoreNewlines()
        this.consume(TokenType.TokRightParen, "Expect ')' at the end of an attribute")
      }
      this.ignoreNewlines()
      attributes.push(Expr(
        expr: ExprDef.EAttribute(
          path: path,
          args: args
        ),
        pos: start.pos.merge(this.previous().pos)
      ))
    } while (this.matches([ TokenType.TokComma ]))
    
    this.consume(TokenType.TokRightBracket, "Expect a ']' at the end of an attribute")
    this.ignoreNewlines()
    
    if (this.matches([ TokenType.TokLeftBracket ])) {
      attributes = attributes.concat(attributeList())
    }

    return attributes
  }

  private expressionStatement() {
    var expr = this.expression()
    this.expectEndOfStatement()
    return Stmt(
      stmt: StmtDef.SExpr(expr),
      pos: expr.pos
    )
  }

  private block(): Array<Stmt> {
    var statements: Array<Stmt> = []

    this.ignoreNewlines()

    while (!this.check(TokenType.TokRightBrace) && !this.isAtEnd()) {
      statements.push(this.declaration())
    }
    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect '}' at the end of a block.")
    
    return statements
  }

  private blockStatement(): Stmt {
    var start = this.previous()
    var statements = this.block()

    this.ignoreNewlines()

    return Stmt(
      stmt: StmtDef.SBlock(statements),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private ifStatement(): Stmt {
    var start = this.previous()

    this.consume(TokenType.TokLeftParen, "Expect '(' after 'if'.")

    this.ignoreNewlines()
    var condition: Expr = this.expression()
    this.ignoreNewlines()

    this.consume(TokenType.TokRightParen, "Expect ')' after if condition.")

    var thenBranch: Stmt = this.statement()
    var def: StmtDef = thenBranch.stmt

    match (def) {
      SBlock(_) -> null
      default -> thenBranch = Stmt(
        stmt: StmtDef.SBlock([ thenBranch ]),
        pos: thenBranch.pos
      )
    }

    var elseBranch: ?Stmt = null
    if (this.matches([ TokenType.TokElse ])) {
      elseBranch = this.statement()
      var def: StmtDef = elseBranch.stmt
      match (def) {
        SBlock(_) -> null
        default -> elseBranch = Stmt(
          stmt: StmtDef.SBlock([ elseBranch ]),
          pos: elseBranch.pos
        )
      }
    }

    return Stmt(
      stmt: StmtDef.SIf(condition, thenBranch, elseBranch),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private whileStatement(): Stmt {
    var start = this.previous()
    this.consume(TokenType.TokLeftParen, "Expect '(' after 'while'.")
    this.ignoreNewlines()
    var condition = this.expression()
    this.ignoreNewlines()
    this.consume(TokenType.TokRightParen, "Expect ')' after 'while' condition.")
    var body = this.statement()
    return Stmt(
      stmt: StmtDef.SWhile(
        condition: condition,
        body: body,
        inverted: false
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private doStatement(): Stmt {
    var start = this.previous()
    var body = this.statement()

    this.consume(TokenType.TokWhile, "Expect 'while' after a 'do' statment.")
    this.consume(TokenType.TokLeftParen, "Expect '(' after 'while'.")

    var condition = this.expression()
    
    this.consume(TokenType.TokRightParen, "Expect ')' after 'while' condition.")
    
    this.expectEndOfStatement()
    
    return Stmt(
      stmt: StmtDef.SWhile(
        condition: condition,
        body: body,
        inverted: true
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private forStatement(): Stmt {
    var start = this.previous()

    this.consume(TokenType.TokLeftParen, "Expect '(' after 'for'.")
    
    var key = this.consume(TokenType.TokIdentifier, 'Expect an identifier').lexeme
    var value = null
    
    if (this.check(TokenType.TokColon)) {
      this.advance()
      value = this.consume(TokenType.TokIdentifier, 'Expect an identifier after a colon').lexeme
    }

    this.consume(TokenType.TokIn, 'Expect `in` after destructuring')
    var target = this.expression()
    this.consume(TokenType.TokRightParen, "Expect ')'")
    var body = this.statement()

    return Stmt(
      stmt: StmtDef.SFor(
        key: key,
        value: value,
        target: target,
        body: body
      ),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private switchStatement(): Stmt {
    var start = this.previous()
    this.consume(TokenType.TokLeftParen, "Expect '(' after 'switch'.")
    this.ignoreNewlines()
    var target = this.expression()
    this.ignoreNewlines()
    this.consume(TokenType.TokRightParen, "Expect ')' after switch target")
    this.ignoreNewlines()
    this.consume(TokenType.TokLeftBrace, "Expect '{'")
    this.ignoreNewlines()
    
    var cases:Array<MatchCase> = []
    
    while(!this.isAtEnd() && this.matches([ TokenType.TokCase, TokenType.TokDefault ])) {
      this.ignoreNewlines()
      var condition: ?Expr = null
      var isDefault = false
      
      if (this.previous().type == TokenType.TokDefault) {
        isDefault = true
      } else {
        condition = this.expression()
      }

      this.consume(TokenType.TokColon, "Expect a ':' after case condition")
      this.ignoreNewlines()

      var body:Array<Stmt> = []
      while(
        !this.isAtEnd() 
        && !this.check(TokenType.TokCase) 
        && !this.check(TokenType.TokDefault)
        && !this.check(TokenType.TokRightBrace)
      ) {
        body.push(this.statement())
      }

      cases.push(MatchCase(
        condition: condition,
        body: body,
        isDefault: isDefault
      ))
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect a '}' at the end of a switch statement")
    this.ignoreNewlines()

    return Stmt(
      stmt: StmtDef.SSwitch(target, cases),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private throwStatement(): Stmt {
    var start = this.previous()
    var value = this.expression()
    this.expectEndOfStatement()
    return Stmt(
      stmt: StmtDef.SThrow(value),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private tryStatement(): Stmt {
    var start = this.previous()

    this.ignoreNewlines()
    this.consume(TokenType.TokLeftBrace, "Expect '{' after 'try'")
    this.ignoreNewlines()

    var body = blockStatement()
    var catches: Array<Stmt> = []

    this.ignoreNewlines()

    while (this.matches([ TokenType.TokCatch ]) && !this.isAtEnd()) {
      var start = this.previous()
      this.consume(TokenType.TokLeftParen, "Expect '('")
      var name = this.consume(TokenType.TokIdentifier, "Expect an identifier")
      var type: ?TypePath = null
      if (this.matches([ TokenType.TokColon ])) {
        type = this.parseTypePath(false)
      }
      this.consume(TokenType.TokRightParen, "Expect ')'")
      this.consume(TokenType.TokLeftBrace, "Expect '{'")
      this.ignoreNewlines()
      
      var body = this.blockStatement()
      
      catches.push(Stmt(
        stmt: StmtDef.SCatch(
          name: name,
          type: type,
          body: body
        ),
        pos: start.pos.merge(this.previous().pos)
      ))
    }

    return Stmt(
      stmt: StmtDef.STry(body, catches),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private returnStatement(): Stmt {
    var start = this.previous()
    var value: Expr = null
    
    if (!this.check(TokenType.TokSemicolon) && !this.check(TokenType.TokNewline)) {
      value = this.expression()
    }
    
    this.expectEndOfStatement()

    return Stmt(
      stmt: StmtDef.SReturn(value),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private matchExpr(): Expr {
    var start = this.previous()
    this.consume(TokenType.TokLeftParen, "Expect '(' after 'match'.")
    this.ignoreNewlines()
    var target = this.expression()
    this.ignoreNewlines()
    this.consume(TokenType.TokRightParen, "Expect ')' after match target")
    this.ignoreNewlines()
    this.consume(TokenType.TokLeftBrace, "Expect '{'")
    this.ignoreNewlines()
    
    var cases:Array<MatchCase> = []    

    while(!this.isAtEnd() && !this.check(TokenType.TokRightBrace)) {
      this.ignoreNewlines()
      
      var isDefault = false
      var condition: ?Expr = null
      
      if (this.matches([ TokenType.TokDefault ])) {
        isDefault = true
      } else {
        condition = this.expression()
      }

      this.consume(TokenType.TokArrow, 'Expect a -> after matches')
      this.ignoreNewlines()
      
      var body = this.statement()

      cases.push(MatchCase(
        condition: condition,
        body: [ body ],
        isDefault: isDefault
      ))
    }

    this.ignoreNewlines()
    this.consume(TokenType.TokRightBrace, "Expect a '}' at the end of a match statement")

    return Expr(
      expr: ExprDef.EMatch(target, cases),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private expression(): Expr {
    return this.assignment()
  }

  private assignment(): Expr {
    var expr: Expr = this.or()
    
    if (this.matches([ TokenType.TokEqual ])) {
      // Todo: how do we handle TokPlusEqual?

      this.ignoreNewlines()
      var value: Expr = this.assignment()
      var def: ExprDef = expr.expr

      match (def) {
        EVariable(name) -> return Expr(
          expr: ExprDef.EAssign(name, value),
          pos: expr.pos.merge(value.pos)
        )
        EGet(target, field) -> return Expr(
          expr: ExprDef.ESet(target, field, value),
          pos: expr.pos.merge(value.pos)
        )
        EArrayGet(target, field) -> return Expr(
          expr: ExprDef.EArraySet(target, field, value),
          pos: expr.pos.merge(value.pos)
        )
        default -> throw this.error(this.previous(), "Invalid assignment target")
      }
    }

    return expr
  }

  private or(): Expr {
    var expr: Expr = this.and()

    while (this.matches([ TokenType.TokBoolOr ])) {
      var op: Token = this.previous()
      this.ignoreNewlines();
      var right: Expr = this.and()

      expr = Expr(
        expr: ExprDef.ELogical(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }

  private and(): Expr {
    var expr: Expr = this.equality()

    while (this.matches([ TokenType.TokBoolAnd ])) {
      var op: Token = this.previous()
      this.ignoreNewlines()
      var right: Expr = this.equality()

      expr = Expr(
        expr: ExprDef.ELogical(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }

  private equality(): Expr {
    var expr: Expr = this.comparison()

    while (this.matches([ TokenType.TokBangEqual, TokenType.TokBoolEqual ])) {
      var op: Token = this.previous()
      this.ignoreNewlines()
      var right: Expr = this.comparison()
      
      expr = Expr(
        expr: ExprDef.EBinary(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }

  private comparison(): Expr {
    var expr: Expr = this.addition()

    if (this.matches([ TokenType.TokIs ])) {
      var type = this.parseTypePath()
      var pos = expr.pos.merge(this.previous().pos)

      this.ignoreNewlines()
      
      return Expr(
        expr: ExprDef.EIs(expr, type),
        pos: pos
      )
    }

    while(this.matches([
      TokenType.TokGreater,
      TokenType.TokGreaterEqual,
      TokenType.TokLess,
      TokenType.TokLessEqual
    ])) {
      var op = this.previous()
      this.ignoreNewlines()
      var right = this.addition()
      expr = Expr(
        expr: ExprDef.EBinary(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }

  private addition(): Expr {
    var expr: Expr = this.multiplication()

    while (this.matches([
      TokenType.TokMinus,
      TokenType.TokPlus
    ])) {
      var op: Token = this.previous()
      this.ignoreNewlines()
      var right: Expr = this.multiplication()
      expr = Expr(
        expr: ExprDef.EBinary(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }

  private multiplication(): Expr {
    var expr: Expr = this.range()

    while (this.matches([
      TokenType.TokSlash,
      TokenType.TokStar
    ])) {
      var op: Token = this.previous()
      this.ignoreNewlines()
      var right: Expr = this.range()
      expr = Expr(
        expr: ExprDef.EBinary(expr, op.lexeme, right),
        pos: expr.pos.merge(right.pos)
      )
    }

    return expr
  }
  
  private range(): Expr {
    var expr: Expr = this.pipe()

    while (this.matches([ TokenType.TokRange ])) {
      this.ignoreNewlines()
      var to: Expr = this.pipe()
      expr = Expr(
        expr: ExprDef.ERange(expr, to),
        pos: expr.pos.merge(to.pos)
      )
    }

    return expr
  }

  private pipe(): Expr {
    var expr = this.unary()

    while (this.matches([ TokenType.TokPipe ])) {
      var op = this.previous()
      var target: Expr = this.unary()
      var def: ExprDef = target.expr

      match(def) {
        ECall(callee, args) -> {
          expr = Expr(
            expr: ExprDef.ECall(callee, args.concat([
              CallArgument.Positional(expr)
            ])),
            pos: target.pos
          )
        }
        ELambda(func) -> {
          expr = Expr(
            expr: ExprDef.ECall(
              Expr(expr: ExprDef.EGrouping(target), pos: target.pos),
              [ CallArgument.Positional(expr) ]
            ),
            pos: target.pos
          )
        }
        default -> throw error(op, 'Expected a function/method call or a lambda')
      }
    }

    return expr
  }

  private unary(): Expr {
    if (this.matches([
      TokenType.TokBang,
      TokenType.TokMinus,
      TokenType.TokPlusPlus,
      TokenType.TokMinusMinus
    ])) {
      var op = this.previous()
      this.ignoreNewlines()
      var target = this.unary()
      return Expr(
        expr: ExprDef.EUnary(op.lexeme, target, true),
        pos: op.pos.merge(target.pos)
      )
    }

    var expr = this.call()

    if (this.matches([
      TokenType.TokPlusPlus,
      TokenType.TokMinusMinus
    ])) {
      var op = this.previous()
      return Expr(
        expr: ExprDef.EUnary(op.lexeme, expr, false),
        pos: expr.pos.merge(op.pos)
      )
    }

    return expr
  }

  private call(): Expr {
    var expr: Expr = this.primary()

    while (!this.isAtEnd()) {
      this.conditionalIgnoreNewlines()

      if (this.matches([ TokenType.TokLeftParen ])) {
        expr = this.finishCall(expr)
      } else if (this.matches([ TokenType.TokLeftBrace ])) {
        var arg = this.shortLambda(!this.check(TokenType.TokNewline))
        expr = Expr(
          expr: ExprDef.ECall(
            expr,
            [ CallArgument.Positional(arg) ]
          ),
          pos: expr.pos.merge(arg.pos)
        )
      } else if (this.matches([ TokenType.TokDot ])) {
        this.ignoreNewlines()
        var name: Expr = null
        if (this.matches([ TokenType.TokLeftBrace ])) {
          this.ignoreNewlines()
          var ret: Expr = this.expression()
          var def: ExprDef = ret.expr
          
          match (def) {
            EVariable(_) -> {
              ret = ExprDef.Expr(
                expr: EGrouping(ret),
                pos: ret.pos 
              )
            }
            default -> null
          }

          this.ignoreNewlines()
          this.consume(TokenType.TokRightBrace, "Expect a '}'")
          name = ret
        } else if (this.matches([ TokenType.TokTypeIdentifier, TokenType.TokClass ])) {
          name = Expr(
            expr: ExprDef.EVariable(this.previous().lexeme),
            pos: this.previous().pos
          )
        } else {
          var tok = this.consume(TokenType.TokIdentifier, "Expect property name after '.'.")
          name = Expr(
            expr: ExprDef.EVariable(tok.lexeme),
            pos: tok.pos
          )
        }
        expr = Expr(
          expr: ExprDef.EGet(expr, name),
          pos: expr.pos.merge(name.pos)
        )
      } else if (this.matches([ TokenType.TokLeftBracket ])) {
        if (this.matches([ TokenType.TokRightBracket ])) {
          expr = Expr(
            expr: ExprDef.EArrayGet(expr, null),
            pos: expr.pos.merge(this.previous().pos)
          )
        } else {
          this.ignoreNewlines()
          var index = this.expression()
          var tok = this.consume(TokenType.TokRightBracket, "Expect ']' after expression")
          expr = Expr(
            expr: ExprDef.EArrayGet(expr, index),
            pos: expr.pos.merge(tok.pos)
          )
        }
      } else {
        break
      }
    }

    return expr
  }

  private finishCall(expr: Expr) {
    var args: Array<CallArgument> = []
    if (!this.check(TokenType.TokRightParen)) {
      args = this.parseArguments()
    }
    this.ignoreNewlines()
    this.consume(TokenType.TokRightParen, "Expect ')' after arguments")
    
    // Handle trailing arguments (eg, `foo('a') { it }`)
    if (this.matches([ TokenType.TokLeftBrace ])) {
      args.push(CallArgument.Positional(this.shortLambda(!this.check(TokenType.TokNewline))))
    }

    return Expr(
      expr: ExprDef.ECall(expr, args),
      pos: expr.pos.merge(this.previous().pos)
    )
  }

  private parseArguments(): Array<CallArgument> {
    var isAfterNamedArgument = false
    return this.parseList(TokenType.TokComma) {
      if (this.check(TokenType.TokIdentifier) && this.checkNext(TokenType.TokColon)) {
        isAfterNamedArgument = true
        this.consume(TokenType.TokIdentifier, 'expected an identifier')
        var name = this.previous().lexeme
        this.consume(TokenType.TokColon, 'expected a ":"')
        var expr = this.expression()
        return CallArgument.Named(name, expr)
      } else {
        if (isAfterNamedArgument) {
          throw this.error(this.peek(), 'Positional arguments cannot come after named ones')
        }
        return CallArgument.Positional(this.expression())
      }
    }
  }

  private ternary(): Expr {
    var start = this.previous()
    this.consume(TokenType.TokLeftParen, "Expect '(' after 'if'.")
    var condition: Expr = this.expression()
    this.consume(TokenType.TokRightParen, "Expect ')' after if condition.")
    this.ignoreNewlines()
    var thenBranch = this.expression()
    this.ignoreNewlines()
    this.consume(TokenType.TokElse, "Expected an 'else' branch")
    this.ignoreNewlines()
    var elseBranch = this.expression()
    return Expr(
      expr: ExprDef.ETernary(condition, thenBranch, elseBranch),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private arrayOrMapLiteral(isNative: Bool = false): Expr {
    this.ignoreNewlines()
    if (this.checkNext(TokenType.TokColon)) {
      return this.mapLiteral(isNative)
    }
    return this.arrayLiteral(isNative)
  }

  private arrayLiteral(isNative: Bool): Expr {
    var start: Token = this.previous()
    var rewindPoint = this.current
    var values: Array<Expr> = []

    if (!this.check(TokenType.TokRightBracket)) {
      values = this.parseList(TokenType.TokComma) { this.expression() }
    }

    if (this.matches([ TokenType.TokColon ])) {
      this.current = rewindPoint
      return this.mapLiteral(isNative)
    }

    this.ignoreNewlines() // May be a newline after the last item in the list
    var end = this.consume(TokenType.TokRightBracket, "Expect ']' after values")
    return Expr(
      expr: ExprDef.EArrayLiteral(
        values: values,
        isNative: isNative
      ),
      pos: start.pos.merge(end.pos)
    )
  }

  private mapLiteral(isNative: Bool): Expr {
    var start: Token = this.previous()
    var keys: Array<Expr> = []
    var values: Array<Expr> = []

    if (!this.check(TokenType.TokRightBracket)) {
      do {
        this.ignoreNewlines()
        keys.push(this.expression())
        this.consume(TokenType.TokColon, "Expect ':' after map keys")
        this.ignoreNewlines()
        values.push(this.expression())
      } while (this.matches([ TokenType.TokComma ]))
      this.ignoreNewlines()
    }

    var end = this.consume(TokenType.TokRightBracket, "Expect ']' at the end of a mapliteral")
    
    return Expr(
      expr: ExprDef.EMapLiteral(
        keys: keys,
        values: values,
        isNative: isNative
      ),
      pos: start.pos.merge(end.pos)
    )
  }

  private taggedTemplate(callee: Expr): Expr {
    var parts: Array<Expr> = []
    var placeholders: Array<Expr> = []

    // Note: Interpolated strings end on a `TokString`
    if (!this.check(TokenType.TokString)) {
      do {
        if (this.matches([ TokenType.TokInterpolation ])) {
          parts.push(Expr(
            expr: ExprDef.ELiteral(Literal.LString(this.previous().literal)),
            pos: this.previous().pos
          ))
        } else {
          placeholders.push(this.expression())
        }
      } while (!this.check(TokenType.TokString) && !this.isAtEnd())
    }

    parts.push(this.primary())

    var partsPos = if (parts.length > 0)
      parts[0].pos.merge(parts[parts.length - 1].pos)
      else this.previous().pos
      
    var placeholdersPos = if (placeholders.length > 0)
      placeholders[0].pos.merge(placeholders[placeholders.length - 1].pos)
      else this.previous().pos

    return Expr(
      expr: ExprDef.ECall(callee, [
        CallArgument.Positional(Expr(
          expr: ExprDef.EArrayLiteral(parts, false),
          pos: partsPos
        )),
        CallArgument.Positional(Expr(
          expr: ExprDef.EArrayLiteral(placeholders, false),
          pos: placeholdersPos
        ))
      ]),
      pos: callee.pos.merge(this.previous().pos)
    )
  }

  private interpolation(expr: Expr): Expr {
    while (!this.isAtEnd()) {
      var next: Expr = null
      if (this.check(TokenType.TokString)) {
        return Expr(
          expr: ExprDef.EBinary(expr, '+', this.primary()),
          pos: expr.pos.merge(this.previous().pos)
        )
      } else if (this.matches([ TokenType.TokInterpolation ])) {
        next = Expr(
          expr: ExprDef.ELiteral(Literal.LString(this.previous().literal)),
          pos: this.previous().pos
        )
      } else {
        var expr = this.expression()
        next = Expr(
          expr: ExprDef.EGrouping(expr),
          pos: expr.pos
        )
      }
      expr = Expr(
        expr: ExprDef.EBinary(expr, '+', next),
        pos: expr.pos.merge(next.pos)
      )
    }
    throw this.error(this.peek(), "Unexpected end of interpolated string")
  }

  private pathExpr() {
    var start: Token = this.peek()
    var path: TypePath = this.parseTypePath(false)
    return Expr(
      expr: ExprDef.EPath(path),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private primary(): Expr {
    if (this.matches([ TokenType.TokFalse ])) {
      return Expr(
        expr: ExprDef.ELiteral(Literal.LFalse()),
        pos: this.previous().pos
      )
    }
    if (this.matches([ TokenType.TokTrue ])) {
      return Expr(
        expr: ExprDef.ELiteral(Literal.LTrue()),
        pos: this.previous().pos
      )
    }
    if (this.matches([ TokenType.TokNull ])) {
      return Expr(
        expr: ExprDef.ELiteral(Literal.LNull()),
        pos: this.previous().pos
      )
    }
    if (this.matches([ TokenType.TokNumber ])) {
      var literal = this.previous()
      return Expr(
        expr: ExprDef.ELiteral(Literal.LNumber(literal.literal)),
        pos: literal.pos
      )
    }
    if (this.matches([ TokenType.TokString ])) {
      var literal = this.previous()
      return Expr(
        expr: ExprDef.ELiteral(Literal.LString(literal.literal)),
        pos: literal.pos
      )
    }
    if (this.matches([ TokenType.TokInterpolation ])) {
      var literal = this.previous()
      return this.interpolation(Expr(
        expr: ExprDef.ELiteral(Literal.LString(literal.literal)),
        pos: literal.pos
      ))
    }
    if (this.matches([ TokenType.TokSuper ])) {
      var keyword = this.previous()
      this.consume(TokenType.TokDot, "Expect '.' after 'super'.")
      this.ignoreNewlines()
      var method = this.consume(TokenType.TokIdentifier, "Expect superclass method name.")
      return Expr(
        expr: ExprDef.ESuper(method.lexeme),
        pos: keyword.pos.merge(method.pos)
      )
    }
    if (this.matches([ TokenType.TokThis ])) {
      var keyword = this.previous()
      return Expr(
        expr: ExprDef.EThis(),
        pos: keyword.pos
      )
    }
    if (this.matches([ TokenType.TokStatic ])) {
      var keyword = this.previous()
      return Expr(
        expr: ExprDef.EStatic(),
        pos: keyword.pos
      )
    }
    if (
      this.check(TokenType.TokScopeResolutionOperator)
      ||this.check(TokenType.TokTypeIdentifier)
    ) {
      return this.pathExpr();
    }
    if (this.matches([ TokenType.TokIdentifier ])) {
      var variable = this.previous()
      return Expr(
        expr: ExprDef.EVariable(variable.lexeme),
        pos: variable.pos
      )
    }
    if (this.matches([ TokenType.TokTemplateTag ])) {
      var variable = this.previous()
      return this.taggedTemplate(Expr(
        expr: ExprDef.EVariable(variable.lexeme),
        pos: variable.pos
      ))
    }
    if (this.matches([ TokenType.TokLeftParen ])) {
      var start: Token = this.previous()
      this.ignoreNewlines()
      var expr = this.expression()
      this.ignoreNewlines()
      var end = this.consume(TokenType.TokRightParen, "Expect ')' after expression.")
      return Expr(
        expr: ExprDef.EGrouping(expr),
        pos: start.pos.merge(end.pos)
      )
    }
    if (this.matches([ TokenType.TokDollar ])) {
      if (this.matches([ TokenType.TokLeftBracket ])) {
        return this.arrayOrMapLiteral(true);
      }
    }
    if (this.matches([ TokenType.TokLeftBracket ])) {
      return this.arrayOrMapLiteral()
    }
    if (this.matches([ TokenType.TokLeftBrace ])) {
      return this.shortLambda(!this.check(TokenType.TokNewline))
    }
    if (this.matches([ TokenType.TokFunction ])) {
      var start = this.previous()
      return Expr(
        expr: ExprDef.ELambda(this.functionDecl(true)),
        pos: start.pos.merge(this.previous().pos)
      )
    }
    if (this.matches([ TokenType.TokIf ])) {
      return this.ternary()
    }
    if (this.matches([ TokenType.TokMatch ])) {
      return this.matchExpr()
    }

    var tok = this.peek()
    throw this.error(tok, 'Unexpected ${tok.type}')
  }

  private shortLambda(isInline: Bool = false): Expr {
    this.ignoreNewlines()
    
    var start: Token = this.previous()
    var args: Array<FunctionArg> = []
    var body: Array<Stmt> = []

    if (this.matches([ TokenType.TokBar ])) {
      if (!this.check(TokenType.TokBar)) {
        do {
          var name = this.consume(TokenType.TokIdentifier, "Expect an argument name")
          var type = if (this.matches([ TokenType.TokColon ])) this.parseTypePath() else null
          args.push(FunctionArg(
            name: name.lexeme,
            type: type,
            expr: null
          ))
        } while (this.matches([ TokenType.TokComma ]))
      }
      this.consume(TokenType.TokBar, "Expect '|' after lambda arguments")
      isInline = !this.check(TokenType.TokNewline)
    } else {
      args = [
        FunctionArg(
          name: 'it',
          type: null,
          expr: Expr(
            expr: ExprDef.ELiteral(Literal.LNull()),
            pos: this.previous().pos
          )
        )
      ]
    }
    
    if (isInline && !this.check(TokenType.TokReturn)) {
      // Treat the next statement as a return
      var expr = this.expression()
      body.push(Stmt(
        stmt: StmtDef.SReturn(expr),
        pos: expr.pos
      ))
      this.ignoreNewlines()
      this.consume(TokenType.TokRightBrace, 'Inline lambdas must contain only one expression.')
    } else {
      body = this.block()
    }
    
    return Expr(
      expr: ExprDef.ELambda(FunctionDecl(
        name: '',
        args: args,
        body: Stmt(
          stmt: StmtDef.SBlock(body),
          pos: if (body.length > 0)
            body[0].pos.merge(this.previous().pos)
          else
            start.pos.merge(this.previous().pos)
        ),
        ret: null,
        attributes: []
      )),
      pos: start.pos.merge(this.previous().pos)
    )
  }

  private expectEndOfStatement(): Bool {
    if (this.check(TokenType.TokRightBrace)) {
      // special case -- allows stuff like '{ |a| a }'
      // We don't consume it here, as the parser needs to check for it.
      return true
    }
    if (this.matches([ TokenType.TokNewline, TokenType.TokEof ])) {
      // consume any extras
      this.ignoreNewlines()
      return true
    }
    this.consume(TokenType.TokSemicolon, "Expect newline or semicolon after statement")
    this.ignoreNewlines() // consume any newlines
    return false
  }

  private parseTypePath(allowNullable: Bool = true): ?TypePath {
    var nullable: Bool = this.matches([ TokenType.TokQuestion ])
  
    if (nullable && !allowNullable) {
      throw this.error(this.previous(), "Nullable types are not allowed here")
    }

    var absolute: Bool = this.matches([ TokenType.TokScopeResolutionOperator ])
    var parts = this.parseList(TokenType.TokScopeResolutionOperator) {
      return this.consume(TokenType.TokTypeIdentifier, "Expect a package name seperated by '::'")
    }
    var name = parts.pop()
    var params = []

    if (this.matches([ TokenType.TokLess ])) {
      params = this.parseList(TokenType.TokComma) { this.parseTypePath() }
      this.consume(TokenType.TokGreater, "Expect a '>' at the end of a type parameter list")
    }

    return TypePath(
      ns: parts.map { it.lexeme },
      name: name.lexeme,
      params: params,
      isAbsolute: absolute,
      isNullable: nullable
    )
  }

  private parseList(sep: String, parser): Array {
    var items = []
    do {
      this.ignoreNewlines()
      items.push(parser())
    } while (this.matches([ sep ]) && !this.isAtEnd())
    return items
  }

  private ignoreNewlines() {
    while (!this.isAtEnd()) {
      if (!this.matches([ TokenType.TokNewline ])) return
    }
  }

  private conditionalIgnoreNewlines() {
    if (this.check(TokenType.TokNewline)) {
      while (!this.isAtEnd()) {
        if (this.checkNext(TokenType.TokNewline)) this.advance()

        for (token in static.continuationTokens) {
          if (this.checkNext(token)) {
            this.advance()
            return
          }
        }

        if (!this.checkNext(TokenType.TokNewline)) return
      }
    }
  }

  private matches(types: Array<String>): Bool {
    for (type in types) {
      if (this.check(type)) {
        this.advance()
        return true
      }
    }
    return false
  }

  private consume(type: String, message: String): Token {
    if (this.check(type)) {
      return this.advance()
    }
    throw this.error(this.peek(), message)
  }

  private check(type: String): Bool {
    if (this.isAtEnd()) return false
    return this.peek().type == type
  }

  private checkNext(type: String): Bool {
    if (this.isAtEnd()) return false
    return this.peekNext().type == type
  }

  private advance(): ?Token {
    if (!this.isAtEnd()) {
      return this.tokens[this.current++]
    }
    return null
  }

  private peek(): ?Token { this.tokens[this.current] }

  private peekNext(): ?Token { this.tokens[this.current + 1] }

  private previous(): ?Token { this.tokens[this.current - 1] }

  private isAtEnd(): Bool { this.peek().type == TokenType.TokEof }

  private error(token: Token, message: String) {
    this.reporter.report(token.pos, message)
    return ParserException()
  }
}
