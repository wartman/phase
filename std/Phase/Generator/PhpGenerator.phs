namespace Phase::Generator

use Std::StringBuf
use Phase::{
  ErrorReporter,
  Generator,
  Context
}
use Phase::Language::{
  Position,
  Expr,
  ExprDef,
  Literal,
  Stmt,
  StmtDef,
  UseKind,
  UseTarget,
  TypePath,
  CallArgument,
  FunctionArg,
  FunctionDecl,
  Field,
  FieldAccess,
  FieldKind,
  ClassDecl,
  ClassKind,
  MatchCase
}

class PhpGenerator implements Generator {
  static phaseToPhpTypes: Map<String, String> = Map([
    'String': 'string',
    'Int': 'int',
    'Array': '\\Std\\PhaseArray',
    'Map': '\\Std\\PhaseMap',
    'Callable': 'callable',
    'Any': 'mixed',
    'Scalar': 'scalar',
    'Bool': 'bool'
  ])

  private context: Context
  private config: PhpGeneratorConfig
  private statements: Array<Stmt>
  private reporter: ErrorReporter
  private indentLevel: Int = 0
  private uid: Int = 0
  private mode: String = PhpGeneratorMode.GeneratingRoot

  new(
    this.config: PhpGeneratorConfig,
    this.context: Context,
    this.statements: Array<Stmt>,
    this.reporter: ErrorReporter
  ) {}

  generate(): String {
    var out = StringBuf()
    out.add('<?php\n')

    for (stmt in this.statements) {
      out.add(this.generateStmt(stmt))
    }

    return out.toString()
  }

  private generateStmt(stmt: ?Stmt): ?String {
    if (stmt == null) return ''
    var def: StmtDef = stmt.stmt

    return match (def) {
      SNamespace(path, decls, attrs) -> this.generateNamespace(path, decls, attrs)
      SUse(path, kind, attrs) -> null // todo
      SVar(name, type, init) -> this.generateVar(name, type, init)
      SGlobal(name) -> this.stmtOutput()
        .add('global $')
        .add(this.safeVar(name))
        .add(';')
        .toString()
      SThrow(expr) -> this.stmtOutput()
        .add('throw ')
        .add(this.generateExpr(expr))
        .add(';')
        .toString()
      STry(body, catches) -> this.generateTry(body, catches)
      SCatch(name, type, body) -> this.generateCatch(name, type, body)
      SWhile(condition, body, inverted) -> this.generateWhile(condition, body, inverted)
      SFor(key, value, target, body) -> this.generateFor(key, value, target, body)
      SIf(condition, thenBranch, elseBranch) -> this.generateIf(condition, thenBranch, elseBranch)
      SSwitch(target, cases) -> this.generateSwitch(target, cases)
      SBlock(stmts) -> this.getIndent() +++ this.generateBlock(stmts)
      SReturn(value) -> this.stmtOutput()
        .add('return ')
        .add(this.generateExpr(value))
        .add(';')
        .toString()
      SExpr(expr) -> this.stmtOutput()
        .add(this.generateExpr(expr))
        .add(';')
        .toString()
      SFunction(decl) -> this.generateFunction(decl)
      SClass(decl) -> this.generateClass(decl)
    }
  }

  private generateExpr(expr: ?Expr): String {
    if (expr == null) return ''
    var def: ExprDef = expr.expr
    return match (def) {
      EAttribute(path, args) -> ''
      EAssign(name, value) -> ''
      EBinary(left, op, right) -> this.generateBinary(left, op, right)
      EVariable(name) -> this.generateVariable(name)
      default -> ''
    }
  }

  private generateNamespace(path: TypePath, decls: Array<Stmt>, attrs: Array<Expr>) {
    // Todo: handle namespace attributes -- they should only be allowed for the compiler
    var out = StringBuf()
    var name = path.ns.concat([ path.name ]).join('\\')

    out.add('namespace ${name} {\n')
    this.indent()
    for (decl in decls) {
      out.add(this.generateStmt(decl))
    }
    this.outdent()
    return out.add('\n')
      .add(this.getIndent())
      .add('}')
      .toString()
  }

  private generateVar(name: String, type: ?TypePath, init: Expr): String {
    var out = StringBuf()
    return out.add(this.getIndent())
      .add('$')
      .add(this.safeVar(name))
      .add(' = ')
      .add(this.generateExpr(init))
      .add(';')
      .toString()
  }

  private generateWhile(condition: Expr, body: Stmt, inverted: Bool): String {
    if (inverted) {
      return this.stmtOutput()
        .add('do\n')
        .add(this.generateStmt(body))
        .add('\n')
        .add(this.getIndent())
        .add('while (')
        .add(this.generateExpr(condition))
        .add(');')
        .toString()
    }

    return this.stmtOutput()
      .add('while (')
      .add(this.generateExpr(condition))
      .add(')\n')
      .add(this.generateStmt(body))
      .toString()
  }

  private generateFor(key: String, value: ?String, target: Expr, body: Stmt): String {
    var def: ExprDef = target.expr
    match (def) {
      ERange(from, to) -> {
        var key = this.safeVar(key)
        var init = this.generateExpr(from)
        var limit = this.generateExpr(to)
        return this.stmtOutput()
          .add('for ($${key} = ${init}; $${key} < ${limit}; $${key}++)')
          .add(this.generateStmt(body))
          .toString()
      }
      default -> {
        var key = this.safeVar(key)
        var out = this.stmtOutput()
          .add('foreach (')
          .add(this.generateExpr(target))
          .add(' as $${key}')
        if (value != null) {
          out.add(' => $${this.safeVar(value)}')
        }
        return out.add(')\n')
          .add(this.generateStmt(body))
          .toString()
      }
    }
  }

  private generateIf(condition: Expr, thenBranch: Stmt, elseBranch: ?Stmt): String {
    var out = this.stmtOutput()
      .add('if (${this.generateExpr(condition)})\n')
      .add(this.generateStmt(thenBranch))
    if (elseBranch != null) {
      out.add('\n').add(this.getIndent()).add('else\n').add(this.generateStmt(elseBranch))
    }
    return out.toString()
  }

  private generateSwitch(target: Expr, cases: Array<MatchCase>): String {
    // @todo
    return ''
  }

  private generateAttributes(attrs: Array<Expr>): String {
    // todo
    return ''
  }

  private generateFunction(decl: FunctionDecl): String {
    return ''
  }

  private generateFuncitionArgs(args: Array<FunctionArg>): String {
    return ''
  }

  private generateClass(decl: ClassDecl): String {
    var out = StringBuf()
    var props: Array<String> = []
    var body = StringBuf()

    if (decl.attributes.length > 0) {
      out.add(this.generateAttributes(decl.attributes))
      out.add('\n')
    }

    var keyword: String = 'class'
    switch (decl.kind) {
      case ClassKind.KindTrait: keyword = 'trait'
      case ClassKind.KindInterface: keyword = 'interface'
      default:
    }

    out.add(this.getIndent())
      .add(keyword)
      .add(' ')
      .add(decl.name)

    if (decl.superclass != null) {
      out.add(' extends ').add(decl.superclass.toString())
    }

    if (decl.interfaces.length > 0) {
      var keyword = if (decl.kind == ClassKind.KindInterface) ' extends ' else ' implements '
      out.add(keyword).add(decl.interfaces.map { it.toString() }.join(', '))
    }

    out.add('\n').add(this.getIndent()).add('{\n')
    this.indent()

    var prevMode = this.mode
    var classLocalInits = []
    var classStaticInits = []
    var constructor: ?Field = decl.fields.find { it.name == 'new' }
    
    switch (decl.kind) {
      case ClassKind.KindInterface: this.mode = PhpGeneratorMode.GeneratingInterKindInterface
      case ClassKind.KindTrait: this.mode = PhpGeneratorMode.GeneratingTrait
      default: this.mode = PhpGeneratorMode.GeneratingClass
    }

    for (field in decl.fields) {
      var kind: FieldKind = field.kind
      if (field == constructor) continue
      if (this.mode = PhpGeneratorMode.GeneratingInterface) match (kind) {
        FVar(_, _, _) -> continue
        FProp(_, _, _) -> continue
        default -> null
      }
      if (field.attributes.length > 0) {
        body.add(this.generateAttributes(field.attributes))
      }
      match (kind) {
        FProp(_, _, _) -> props.push(this.safeVar(field.name))
        default -> null
      }
      body.add(this.generateField(field, classLocalInits, classStaticInits))
    }

    out.add(body.toString())

    this.outdent()
    this.mode = prevMode
    out.add('\n').add(this.getIndent()).add('}')
    
    return out.toString()
  }

  private generateField(
    field: Field, 
    localInits: Array<String>,
    staticInits: Array<String>
  ): String {
    var isConst: Bool = false
    var out = (StringBuf()).add('\n').add(this.getIndent())
    var kind: FieldKind = field.kind
    var access = field.access.map {
      switch (it) {
        case FieldAccess.AStatic: 
          return 'static'
        case FieldAccess.APublic: 
          return 'public'
        case FieldAccess.APrivate: 
          return 'protected'
        case FieldAccess.AConst: 
          isConst = true
          'const'
        case FieldAccess.AAbstract: 
          return if (this.mode == PhpGeneratorMode.GeneratingInterface) null else 'abstract'
      }
    }.filter { it != null }.join(' ')

    match (kind) {
      FVar(name, type, init) -> {
        var ret = StringBuf()
        var name = this.safeVar(field.name)
        ret.add(access)
        if (this.config.phpVersion >= 8) {
          if (type != null && !isConst) out.add(' ').add(type.toString())
        }
        out.add(if (isConst) ' ' else '$').add(name)
        if (init != null) {
          if (isConst) out.add(' = ').add(this.generateExpr(init))
        } else if (field.access.contains(FieldAccess.AStatic)) {
          staticInits.push('$${name} = ${this.generateExpr(init)}')
        } else {
          localInits.push('${name} = ${this.generateExpr(init)}')
        }
        ret.add(';')
        out.add(ret.toString())
      }
      FUse(type) -> out.add('use ').add(type.toString()).add(';')
      FFun(func) -> {
        var name = if (field.name == 'new') '__construct' else this.safeVar(field.name)
        out.add(access)
          .add(' function ')
          .add(name)
          .add('(')
          .add(this.generateFuncitionArgs(func.args))
          .add(')')
        
        if (func.ret != null && this.config.phpVersion >= 8) {
          out.add(':').add(func.ret.toString())
        }

        if (!field.access.contains(FieldAccess.AAbstract)) {
          for (p in func.args) {
            if (p.isInit) {
              var init = CodeGenerator.generateStmt(
                'this.${p.name} = ${p.name}',
                field.pos,
                this.reporter
              )
              var body: StmtDef = func.body.stmt
              match (body) {
                SBlock(stmts) -> {
                  stmts.unshift(init)
                  func.body.stmt = StmtDef.SBlock(stmts)
                }
                default -> {
                  var body = func.body
                  func.body = Stmt(
                    stmt: StmtDef.SBlock([
                      init,
                      body
                    ]),
                    pos: body.pos
                  ) 
                }
              }
            }
          }
          out.add('\n').add(this.generateStmt(func.body))
        } else {
          out.add(';')
        }
      }
    }

    return out.toString()
  }

  private generateTry(body: Stmt, catches: Array<Stmt>) {
    var out = this.stmtOutput()
      .add('try\n')
      .add(this.generateStmt(body))
    
    for (c in catches) out.add(this.generateStmt(c))

    return out.toString()
  }

  private generateCatch(name: String, type: ?TypePath, body: Stmt) {
    var out = StringBuf()
    var name = this.safeVar(name)
    out.add('\n').add(this.getIndent()).add('catch (')
    if (type != null) {
      out.add(this.phpTypePath(type)).add(' $').add(name).add(')\n')
    } else {
      out.add('$').add(name).add(')\n')
    }
    out.add(this.generateStmt(body))
    return out.toString()
  }

  private generateBlock(stmts: Array<Stmt>) {
    var out = StringBuf()
    return out.add('{\n')
      .add(this.indent().getIndent())
      .add(stmts.map { this.generateStmt(it) }.join('\n'))
      .add('\n')
      .add(this.outdent().getIndent())
      .add('}')
      .toString()
  }

  private generateVariable(name: String): String {
    return '$${this.safeVar(name)}' // @todo
  }

  private generateBinary(left: Expr, op: String, right: Expr): String {
    var out = StringBuf()
    var stringType = this.context.getType('String')
    out.add(this.generateExpr(left))
    switch (op) {
      case '+': 
        if (this.context.unify(left.type, stringType)) {
          return out.add('.').add(this.generateExpr(right))
        }
        return out.add('+').add(this.generateExpr(right))
      default:
        return out.add(op).add(this.generateExpr(right))
    }
  }

  private indent() {
    this.indentLevel++
    return this
  }

  private outdent() {
    this.indentLevel--
    if (this.indentLevel < 0) {
      this.indentLevel = 0
    }
    return this
  }

  private getIndent(): String {
    var out = StringBuf()
    for (i in 0..this.indentLevel) {
      out.add('    ')
    }
    return out.toString()
  }

  private safeVar(name: String) {
    // @todo: check reserved names
    return name 
  }

  private stmtOutput() { (StringBuf()).add(this.getIndent()) }

  private phpTypePath(type: TypePath) {
    var out = type.ns.concat([ type.name ]).join('//')
    if (out == 'Any') return 'mixed'
    if (static.phaseToPhpTypes.contains(out)) {
      out = static.phaseToPhpTypes.get(out);
      return if (type.isNullable) '?${out}' else out 
    }
    if (type.isAbsolute) {
      out = '//${out}'
    }
    if (type.isNullable) {
      out = '?${out}'
    }
    return out
  }
}
