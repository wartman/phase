namespace Std

use ArrayAccess 
use ArrayIterator
use Countable
use IteratorAggregate
use Traversable

class PhaseArray
  implements ArrayAccess 
  implements Countable
  implements IteratorAggregate
  implements Traversable
{
  private data: $array

  new(this.data: $array = $[]) {}

  length: Int { 
    get { count(this.data) }
  }

  at(index: Int) { this.data[index] }
  
  insert(index: Int, value): Int { this.data[index] = value }

  push(value): Int {
    this.data[] = value
    return this.length
  }

  copy(): PhaseArray { clone(this) }

  filter(f): PhaseArray {
    var out = []
    for (item in this.data) {
      if (f(item)) {
        out.push(item)
      }
    }
    return out
  }

  find(elt): ?Any {
    for (item in this.data) {
      if (elt(item)) return item
    }
    return null
  }

  map(transform): PhaseArray {
    var out = []
    for (item in this.data) {
      item |> transform() |> out.push()
    }
    return out
  }

  contains(item): Bool {
    return this.indexOf(item) > -1
  }

  indexOf(item): Int {
    var index = array_search(item, this.data, true)
    return if (index == false) -1 else index
  }

  remove(item): Bool {
    var removed = false
    for (index in 0..this.length) {
      if (this.data[index] == item) {
        array_splice(this.data, index, 1)
        removed = true
        break
      }
    }
    return removed
  }

  reverse() {
    this.data = array_reverse(this.data);
  }

  pop() {
    return array_pop(this.data)
  }

  shift() {
    return array_shift(this.data)
  }

  sort(f) {
    usort(this.data, f)
  }

  join(sep: String): String {
    return this.data |> implode(sep)
  }

  slice(pos: Int, end: Int = null): PhaseArray {
    if (pos < 0) {
      pos = pos + this.length
    }
    if (pos < 0) {
      pos = 0
    }
    if (end == null) {
      return array_slice(this.data, pos)
    } else {
      if (end <= 0) {
        end = end + this.length
      }
      if (end <= pos) {
        return []
      } else {
        return array_slice(this.data, pos, end - pos)
      }
    }
  }

  concat(other: PhaseArray) {
    return PhaseArray(array_merge(this.data, other.unwrap()))
  }
  
  splice(pos: Int, len: Int): PhaseArray {
    if (len < 0) return [];
    return array_splice(this.data, pos, len)
  }

  unshift(item) { array_unshift(this.data, item) }

  offsetGet(offset) {
    try {
      return this.data[offset]
    } catch (e: ::Throwable) {
      return null
    }
  }

  offsetExists(offset) { this.data[offset] |> isset() }

  offsetSet(offset, value) {
    if (offset == null) {
      this.data[] = value
    } else {
      this.insert(offset, value)
    }
  }

  offsetUnset(offset) {
    if (this.data[offset] |> isset()) {
      this.data[offset] |> unset()
    }
  }

  getIterator(): Traversable { ArrayIterator(this.data) }

  count(): Int { this.length }

  unwrap() { this.data }
}
