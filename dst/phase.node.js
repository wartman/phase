// Generated by Haxe 4.0.0-rc.2+77068e10c
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileInput
});
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.withExtension = function(path,ext) {
	var s = new haxe_io_Path(path);
	s.ext = ext;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g = 1;
	var _g1 = paths1.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2 = 0;
	var _g3 = tmp.length;
	while(_g2 < _g3) {
		var i = _g2++;
		var _g21 = tmp.charCodeAt(i);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i1 = _g21;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i1);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i2 = _g21;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i2);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(((o) instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	if(Object.prototype.hasOwnProperty.call(cc,"__interfaces__")) {
		var intf = cc.__interfaces__;
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(((o) instanceof cl)) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		if(o.__enum__ != null) {
			return $hxEnums[o.__enum__] == cl;
		} else {
			return false;
		}
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var phase_ErrorReporter = function() { };
phase_ErrorReporter.__name__ = true;
phase_ErrorReporter.prototype = {
	__class__: phase_ErrorReporter
};
var phase_Expr = function() { };
phase_Expr.__name__ = true;
phase_Expr.prototype = {
	__class__: phase_Expr
};
var phase_Annotation = function(path,params,relative,expr) {
	this.path = path;
	this.params = params;
	this.relative = relative;
	this.expr = expr;
};
phase_Annotation.__name__ = true;
phase_Annotation.__interfaces__ = [phase_Expr];
phase_Annotation.prototype = {
	accept: function(visitor) {
		return visitor.visitAnnotationExpr(this);
	}
	,__class__: phase_Annotation
};
var phase_Assign = function(name,value) {
	this.name = name;
	this.value = value;
};
phase_Assign.__name__ = true;
phase_Assign.__interfaces__ = [phase_Expr];
phase_Assign.prototype = {
	accept: function(visitor) {
		return visitor.visitAssignExpr(this);
	}
	,__class__: phase_Assign
};
var phase_Binary = function(left,op,right) {
	this.left = left;
	this.op = op;
	this.right = right;
};
phase_Binary.__name__ = true;
phase_Binary.__interfaces__ = [phase_Expr];
phase_Binary.prototype = {
	accept: function(visitor) {
		return visitor.visitBinaryExpr(this);
	}
	,__class__: phase_Binary
};
var phase_Unary = function(op,expr,right) {
	this.op = op;
	this.expr = expr;
	this.right = right;
};
phase_Unary.__name__ = true;
phase_Unary.__interfaces__ = [phase_Expr];
phase_Unary.prototype = {
	accept: function(visitor) {
		return visitor.visitUnaryExpr(this);
	}
	,__class__: phase_Unary
};
var phase_Is = function(left,type) {
	this.left = left;
	this.type = type;
};
phase_Is.__name__ = true;
phase_Is.__interfaces__ = [phase_Expr];
phase_Is.prototype = {
	accept: function(visitor) {
		return visitor.visitIsExpr(this);
	}
	,__class__: phase_Is
};
var phase_Logical = function(left,op,right) {
	this.left = left;
	this.op = op;
	this.right = right;
};
phase_Logical.__name__ = true;
phase_Logical.__interfaces__ = [phase_Expr];
phase_Logical.prototype = {
	accept: function(visitor) {
		return visitor.visitLogicalExpr(this);
	}
	,__class__: phase_Logical
};
var phase_Range = function(from,to) {
	this.from = from;
	this.to = to;
};
phase_Range.__name__ = true;
phase_Range.__interfaces__ = [phase_Expr];
phase_Range.prototype = {
	accept: function(visitor) {
		return visitor.visitRangeExpr(this);
	}
	,__class__: phase_Range
};
var phase_Call = function(callee,paren,args) {
	this.callee = callee;
	this.paren = paren;
	this.args = args;
};
phase_Call.__name__ = true;
phase_Call.__interfaces__ = [phase_Expr];
phase_Call.prototype = {
	accept: function(visitor) {
		return visitor.visitCallExpr(this);
	}
	,__class__: phase_Call
};
var phase_Get = function(object,name) {
	this.object = object;
	this.name = name;
};
phase_Get.__name__ = true;
phase_Get.__interfaces__ = [phase_Expr];
phase_Get.prototype = {
	accept: function(visitor) {
		return visitor.visitGetExpr(this);
	}
	,__class__: phase_Get
};
var phase_Set = function(object,name,value) {
	this.object = object;
	this.name = name;
	this.value = value;
};
phase_Set.__name__ = true;
phase_Set.__interfaces__ = [phase_Expr];
phase_Set.prototype = {
	accept: function(visitor) {
		return visitor.visitSetExpr(this);
	}
	,__class__: phase_Set
};
var phase_SubscriptGet = function(end,object,index) {
	this.end = end;
	this.object = object;
	this.index = index;
};
phase_SubscriptGet.__name__ = true;
phase_SubscriptGet.__interfaces__ = [phase_Expr];
phase_SubscriptGet.prototype = {
	accept: function(visitor) {
		return visitor.visitSubscriptGetExpr(this);
	}
	,__class__: phase_SubscriptGet
};
var phase_SubscriptSet = function(end,object,index,value) {
	this.end = end;
	this.object = object;
	this.index = index;
	this.value = value;
};
phase_SubscriptSet.__name__ = true;
phase_SubscriptSet.__interfaces__ = [phase_Expr];
phase_SubscriptSet.prototype = {
	accept: function(visitor) {
		return visitor.visitSubscriptSetExpr(this);
	}
	,__class__: phase_SubscriptSet
};
var phase_Ternary = function(condition,thenBranch,elseBranch) {
	this.condition = condition;
	this.thenBranch = thenBranch;
	this.elseBranch = elseBranch;
};
phase_Ternary.__name__ = true;
phase_Ternary.__interfaces__ = [phase_Expr];
phase_Ternary.prototype = {
	accept: function(visitor) {
		return visitor.visitTernaryExpr(this);
	}
	,__class__: phase_Ternary
};
var phase_Super = function(keyword,method) {
	this.keyword = keyword;
	this.method = method;
};
phase_Super.__name__ = true;
phase_Super.__interfaces__ = [phase_Expr];
phase_Super.prototype = {
	accept: function(visitor) {
		return visitor.visitSuperExpr(this);
	}
	,__class__: phase_Super
};
var phase_This = function(keyword) {
	this.keyword = keyword;
};
phase_This.__name__ = true;
phase_This.__interfaces__ = [phase_Expr];
phase_This.prototype = {
	accept: function(visitor) {
		return visitor.visitThisExpr(this);
	}
	,__class__: phase_This
};
var phase_Static = function(keyword) {
	this.keyword = keyword;
};
phase_Static.__name__ = true;
phase_Static.__interfaces__ = [phase_Expr];
phase_Static.prototype = {
	accept: function(visitor) {
		return visitor.visitStaticExpr(this);
	}
	,__class__: phase_Static
};
var phase_Grouping = function(expression) {
	this.expression = expression;
};
phase_Grouping.__name__ = true;
phase_Grouping.__interfaces__ = [phase_Expr];
phase_Grouping.prototype = {
	accept: function(visitor) {
		return visitor.visitGroupingExpr(this);
	}
	,__class__: phase_Grouping
};
var phase_Literal = function(value) {
	this.value = value;
};
phase_Literal.__name__ = true;
phase_Literal.__interfaces__ = [phase_Expr];
phase_Literal.prototype = {
	accept: function(visitor) {
		return visitor.visitLiteralExpr(this);
	}
	,__class__: phase_Literal
};
var phase_ArrayLiteral = function(end,values) {
	this.end = end;
	this.values = values;
};
phase_ArrayLiteral.__name__ = true;
phase_ArrayLiteral.__interfaces__ = [phase_Expr];
phase_ArrayLiteral.prototype = {
	accept: function(visitor) {
		return visitor.visitArrayLiteralExpr(this);
	}
	,__class__: phase_ArrayLiteral
};
var phase_AssocArrayLiteral = function(end,keys,values) {
	this.end = end;
	this.keys = keys;
	this.values = values;
};
phase_AssocArrayLiteral.__name__ = true;
phase_AssocArrayLiteral.__interfaces__ = [phase_Expr];
phase_AssocArrayLiteral.prototype = {
	accept: function(visitor) {
		return visitor.visitAssocArrayLiteralExpr(this);
	}
	,__class__: phase_AssocArrayLiteral
};
var phase_Lambda = function(func) {
	this.func = func;
};
phase_Lambda.__name__ = true;
phase_Lambda.__interfaces__ = [phase_Expr];
phase_Lambda.prototype = {
	accept: function(visitor) {
		return visitor.visitLambdaExpr(this);
	}
	,__class__: phase_Lambda
};
var phase_Type = function(path,absolute) {
	this.path = path;
	this.absolute = absolute;
};
phase_Type.__name__ = true;
phase_Type.__interfaces__ = [phase_Expr];
phase_Type.prototype = {
	accept: function(visitor) {
		return visitor.visitTypeExpr(this);
	}
	,__class__: phase_Type
};
var phase_Namespaced = function(type,name) {
	this.type = type;
	this.name = name;
};
phase_Namespaced.__name__ = true;
phase_Namespaced.__interfaces__ = [phase_Expr];
phase_Namespaced.prototype = {
	accept: function(visitor) {
		return visitor.visitNamespacedExpr(this);
	}
	,__class__: phase_Namespaced
};
var phase_Variable = function(name) {
	this.name = name;
};
phase_Variable.__name__ = true;
phase_Variable.__interfaces__ = [phase_Expr];
phase_Variable.prototype = {
	accept: function(visitor) {
		return visitor.visitVariableExpr(this);
	}
	,__class__: phase_Variable
};
var phase_ExprVisitor = function() { };
phase_ExprVisitor.__name__ = true;
phase_ExprVisitor.prototype = {
	__class__: phase_ExprVisitor
};
var phase_NodeCompiler = $hx_exports["Compiler"] = function() { };
phase_NodeCompiler.__name__ = true;
phase_NodeCompiler.compile = $hx_exports["compile"] = function(src,options,relative) {
	if(relative == null) {
		relative = haxe_io_Path.normalize(src);
	}
	if(options == null) {
		options = { annotation : "on-class"};
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = js_node_Fs.readdirSync(src);
	while(_g1 < _g2.length) {
		var name = _g2[_g1];
		++_g1;
		var path = haxe_io_Path.join([src,name]);
		_g.push(sys_FileSystem.isDirectory(path) ? phase_NodeCompiler.compile(path,options,relative) : Lambda.has(phase_NodeCompiler.extensions,haxe_io_Path.extension(path)) ? phase_NodeCompiler.compileFile(path,options,relative) : Promise.resolve(null));
	}
	return Promise.all(_g).then(function(parts) {
		return Lambda.fold(parts.filter(function(p) {
			return p != null;
		}),function(value,result) {
			if(((value) instanceof Array) && value.__enum__ == null) {
				return result.concat(value);
			}
			result.push(value);
			return result;
		},[]);
	});
};
phase_NodeCompiler.write = $hx_exports["write"] = function(dst,modules) {
	var _g = 0;
	while(_g < modules.length) {
		var m = modules[_g];
		++_g;
		var path = haxe_io_Path.withExtension(haxe_io_Path.join([dst,m.name]),"php");
		var dir = haxe_io_Path.directory(path);
		if(!sys_FileSystem.exists(dir)) {
			sys_FileSystem.createDirectory(dir);
		}
		js_node_Fs.writeFileSync(path,m.generated);
	}
	return Promise.resolve(modules);
};
phase_NodeCompiler.compileFile = function(path,options,relative) {
	var source = phase_NodeCompiler.load(path);
	var reporter = new phase_VisualErrorReporter(source);
	var scanner = new phase_Scanner(source,path,reporter);
	var parser = new phase_Parser(scanner.scan(),reporter);
	var generator = new phase_PhpGenerator(parser.parse(),reporter,options);
	if(reporter.hadError()) {
		return Promise.reject("Parsing failed: " + path);
	}
	return Promise.resolve({ realPath : path, name : haxe_io_Path.withoutExtension(haxe_io_Path.normalize(HxOverrides.substr(path,relative.length + 1,null))), source : source, generated : generator.generate()});
};
phase_NodeCompiler.load = function(path) {
	return js_node_Fs.readFileSync(path,{ encoding : "utf8"});
};
var phase_Parser = function(tokens,reporter) {
	this.inPackage = false;
	this.uid = 0;
	this.tokens = tokens;
	this.reporter = reporter;
};
phase_Parser.__name__ = true;
phase_Parser.prototype = {
	parse: function() {
		var stmts = [];
		this.current = 0;
		this.ignoreNewlines();
		while(!this.isAtEnd()) {
			var stmt = this.declaration();
			if(stmt != null) {
				stmts.push(stmt);
			}
		}
		return stmts;
	}
	,declaration: function(annotation) {
		if(annotation == null) {
			annotation = [];
		}
		try {
			if(this.match(["@"])) {
				return this.declaration(this.annotationList());
			}
			if(this.match(["var"])) {
				if(annotation.length > 0) {
					this.error(this.previous(),"Annotations are not allowed here");
				}
				return this.varDeclaration();
			}
			if(this.match(["global"])) {
				if(annotation.length > 0) {
					this.error(this.previous(),"Annotations are not allowed here");
				}
				return this.globalDeclaration();
			}
			if(this.match(["function"])) {
				return this.functionDeclaration(false,annotation);
			}
			if(this.match(["enum"])) {
				return this.enumDeclaration(annotation);
			}
			if(this.match(["interface"])) {
				return this.interfaceDeclaration(annotation);
			}
			if(this.match(["trait"])) {
				return this.traitDeclaration(annotation);
			}
			if(this.match(["class"])) {
				return this.classDeclaration(annotation);
			}
			if(this.match(["use"])) {
				return this.useDeclaration(annotation);
			}
			if(this.match(["package"])) {
				return this.packageDeclaration(annotation);
			}
			return this.statement();
		} catch( error ) {
			var error1 = ((error) instanceof js__$Boot_HaxeError) ? error.val : error;
			if(((error1) instanceof phase_ParserError)) {
				var error2 = error1;
				this.synchronize();
				return null;
			} else {
				throw error;
			}
		}
	}
	,statement: function() {
		if(this.match(["if"])) {
			return this.ifStatement();
		}
		if(this.match(["while"])) {
			return this.whileStatement();
		}
		if(this.match(["for"])) {
			return this.forStatement();
		}
		if(this.match(["switch"])) {
			return this.switchStatement();
		}
		if(this.match(["return"])) {
			return this.returnStatement();
		}
		if(this.match(["throw"])) {
			return this.throwStatement();
		}
		if(this.match(["try"])) {
			return this.tryStatement();
		}
		if(this.match(["{"])) {
			return this.blockStatement();
		}
		return this.expressionStatement();
	}
	,packageDeclaration: function(annotation) {
		var _gthis = this;
		if(this.inPackage) {
			this.error(this.previous(),"Packages cannot be nested");
		}
		this.inPackage = true;
		var path = this.parseList("::",function() {
			return _gthis.consume("[type-identifier]","Expect a package name seperated by '::'");
		});
		this.consume("{","Expect `{` after a package name.");
		this.ignoreNewlines();
		var decls = [];
		while(!this.check("}") && !this.isAtEnd()) decls.push(this.declaration());
		this.consume("}","Expect `}` at the end of a package declaration.");
		this.ignoreNewlines();
		this.inPackage = false;
		return new phase_Package(path,decls,annotation);
	}
	,useDeclaration: function(annotation) {
		var _gthis = this;
		if(!this.inPackage) {
			this.error(this.previous(),"`use` is not allowed outside a package");
		}
		var kind = phase_UseKind.UseNormal;
		var absolute = false;
		var path = [];
		if(this.match(["::"])) {
			absolute = true;
		}
		while(true) {
			this.ignoreNewlines();
			if(this.match(["[type-identifier]"])) {
				path.push(this.previous());
			} else if(this.match(["[identifier]"])) {
				kind = phase_UseKind.UseSub([phase_UseTarget.TargetFunction(this.previous())]);
				if(this.match(["::"])) {
					throw new js__$Boot_HaxeError(this.error(this.previous(),"Lowercase identifiers may only come at the end of a use statement."));
				}
				break;
			} else if(this.match(["{"])) {
				kind = phase_UseKind.UseSub(this.parseList(",",function() {
					if(_gthis.match(["[type-identifier]","[identifier]"])) {
						var tok = _gthis.previous();
						if(tok.type == "[identifier]") {
							return phase_UseTarget.TargetFunction(tok);
						} else {
							return phase_UseTarget.TargetType(tok);
						}
					} else {
						var kind1 = _gthis.peek();
						throw new js__$Boot_HaxeError(_gthis.error(kind1,"Expect an identifier or a type identifier"));
					}
				}));
				this.ignoreNewlines();
				this.consume("}","Expect a '}'.");
				break;
			} else {
				throw new js__$Boot_HaxeError(this.error(this.previous(),"Expected a type identifier or a '{'"));
			}
			if(!(this.match(["::"]) && !this.isAtEnd())) {
				break;
			}
		}
		if(this.match(["as"])) {
			if(this.match(["[type-identifier]","[identifier]"])) {
				var tok1 = this.previous();
				if(kind._hx_index == 2 && (kind.items.length == 1 && kind.items[0]._hx_index == 1)) {
					var p = kind.items[0].name;
					path.push(p);
				}
				kind = phase_UseKind.UseAlias(tok1.type == "[identifier]" ? phase_UseTarget.TargetFunction(tok1) : phase_UseTarget.TargetType(tok1));
			} else {
				throw new js__$Boot_HaxeError(this.error(this.peek(),"Expect an identifier or a type identifier"));
			}
		}
		this.expectEndOfStatement();
		return new phase_Use(path,absolute,kind,annotation);
	}
	,varDeclaration: function() {
		var name = this.consume("[identifier]","Expect variable name.");
		var init = null;
		if(this.match(["="])) {
			init = this.expression();
		}
		this.expectEndOfStatement();
		return new phase_Var(name,init);
	}
	,globalDeclaration: function() {
		var name = this.consume("[identifier]","Expect variable name.");
		this.expectEndOfStatement();
		return new phase_Global(name);
	}
	,functionDef: function(isAnnon,annotations) {
		if(annotations == null) {
			annotations = [];
		}
		var name;
		if(!isAnnon || this.check("[identifier]")) {
			name = this.consume("[identifier]","Expect function name.");
		} else {
			name = new phase_Token("[identifier]","",null,this.previous().pos);
		}
		this.consume("(","Expect '(' after function name.");
		var params = this.functionParams();
		var ret = this.typeHint();
		this.consume("{","Expect '{' before function body");
		var body = this.functionBody();
		return new phase_Function(name,params,body,ret,annotations);
	}
	,functionParams: function(allowInit) {
		if(allowInit == null) {
			allowInit = false;
		}
		var params = [];
		if(!this.check(")")) {
			while(true) {
				this.ignoreNewlines();
				var isInit = false;
				if(allowInit && this.match(["this"])) {
					isInit = true;
					this.consume(".","Expect a '.' after 'this'.");
				}
				var name = this.consume("[identifier]","Expect parameter name");
				var type = this.typeHint();
				var expr = null;
				if(this.match(["="])) {
					expr = this.expression();
				}
				params.push({ name : name, type : type, expr : expr, isInit : isInit});
				if(!this.match([","])) {
					break;
				}
			}
		}
		this.ignoreNewlines();
		this.consume(")","Expect ')' after parameters");
		return params;
	}
	,functionBody: function() {
		var body = null;
		if(this.match(["}"])) {
			return new phase_Block([]);
		}
		if(!this.check("[newline]") && !this.check("return")) {
			body = [new phase_Return(this.peek(),this.expression())];
			this.ignoreNewlines();
			this.consume("}","Inline functions must contain only one expression.");
		} else {
			body = this.block();
		}
		return new phase_Block(body);
	}
	,functionDeclaration: function(isInline,annotations) {
		if(isInline == null) {
			isInline = false;
		}
		var def = this.functionDef(isInline,annotations);
		this.ignoreNewlines();
		return def;
	}
	,interfaceDeclaration: function(annotation) {
		var name = this.consume("[type-identifier]","Expect a class name. Must start uppercase.");
		var interfaces = [];
		var fields = [];
		this.ignoreNewlines();
		while(this.match(["extends"]) && !this.isAtEnd()) {
			interfaces.push(this.consume("[type-identifier]","Expect an interface name"));
			this.ignoreNewlines();
		}
		this.consume("{","Expect '{' before interface body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			fields.push(this.fieldDeclaration({ access : [phase_FieldAccess.AAbstract]}));
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of interface body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindInterface,null,interfaces,fields,annotation);
	}
	,traitDeclaration: function(annotation) {
		var name = this.consume("[type-identifier]","Expect a trait name. Must start uppercase.");
		var fields = [];
		this.consume("{","Expect '{' before trait body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			fields.push(this.fieldDeclaration());
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of trait body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindTrait,null,[],fields,annotation);
	}
	,enumDeclaration: function(annotation) {
		var name = this.consume("[type-identifier]","Expect an enum name. Must start uppercase.");
		var fields = [];
		this.consume("{","Expect '{' before trait body.");
		this.ignoreNewlines();
		var index = 0;
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			var fieldName = this.consume("[type-identifier]","Expect an uppercase identifier");
			var value = this.match(["="]) ? this.expression() : new phase_Literal(index);
			++index;
			this.expectEndOfStatement();
			fields.push(new phase_Field(fieldName,phase_FieldKind.FVar(new phase_Var(fieldName,value),null),[phase_FieldAccess.AConst],[]));
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of trait body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindClass,null,[],fields,annotation);
	}
	,classDeclaration: function(annotation) {
		var name = this.consume("[type-identifier]","Expect a class name. Must start uppercase.");
		var superclass = null;
		var interfaces = [];
		var fields = [];
		this.ignoreNewlines();
		while(this.match(["extends","implements"]) && !this.isAtEnd()) {
			switch(this.previous().type) {
			case "extends":
				if(superclass != null) {
					throw new js__$Boot_HaxeError(this.error(this.previous(),"Can only extend once"));
				}
				superclass = this.consume("[type-identifier]","Expect a superclass name");
				break;
			case "implements":
				interfaces.push(this.consume("[type-identifier]","Expect an interface name"));
				break;
			default:
			}
			this.ignoreNewlines();
		}
		this.consume("{","Expect '{' before class body.");
		this.ignoreNewlines();
		while(!this.check("}") && !this.isAtEnd()) {
			this.ignoreNewlines();
			var field = this.fieldDeclaration();
			fields.push(field);
			var _g = field.kind;
			if(_g._hx_index == 2) {
				var func = _g.fun;
				var _g1 = 0;
				var _g11 = func.params;
				while(_g1 < _g11.length) {
					var a = [_g11[_g1]];
					++_g1;
					if(a[0].isInit == true && !Lambda.exists(fields,(function(a1) {
						return function(f) {
							return f.name.lexeme == a1[0].name.lexeme;
						};
					})(a))) {
						fields.push(new phase_Field(a[0].name,phase_FieldKind.FVar(new phase_Var(a[0].name,null),a[0].type),[phase_FieldAccess.APublic],[]));
					}
				}
			}
		}
		this.ignoreNewlines();
		this.consume("}","Expect '}' at end of class body");
		this.ignoreNewlines();
		return new phase_Class(name,phase_ClassKind.KindClass,superclass,interfaces,fields,annotation);
	}
	,fieldDeclaration: function(options) {
		var _gthis = this;
		if(options == null) {
			options = { access : []};
		}
		if(this.match(["use"])) {
			var out = new phase_Field(this.previous(),phase_FieldKind.FUse(this.parseTypePath()),[],[]);
			this.expectEndOfStatement();
			return out;
		}
		if(this.match(["const"])) {
			var name = this.consume("[type-identifier]","Expect uppercase identifier");
			this.ignoreNewlines();
			this.consume("=","Expect assignment for consts");
			var value = this.expression();
			var out1 = new phase_Field(name,phase_FieldKind.FVar(new phase_Var(name,value),null),[phase_FieldAccess.AConst],[]);
			this.expectEndOfStatement();
			return out1;
		}
		var access = options.access;
		var annotation = [];
		var addAccess = function(a) {
			if(Lambda.has(access,a)) {
				var addAccess1 = _gthis.previous();
				_gthis.error(addAccess1,"Only one `" + Std.string(a) + "` declaration is allowed per field");
			}
			access.push(a);
		};
		if(this.match(["@"])) {
			annotation = this.annotationList();
		}
		while(this.match(["static","public","private","abstract"]) && !this.isAtEnd()) switch(this.previous().type) {
		case "abstract":
			addAccess(phase_FieldAccess.AAbstract);
			break;
		case "private":
			addAccess(phase_FieldAccess.APrivate);
			break;
		case "public":
			addAccess(phase_FieldAccess.APublic);
			break;
		case "static":
			addAccess(phase_FieldAccess.AStatic);
			break;
		default:
		}
		if(access.length == 0 || !Lambda.has(access,phase_FieldAccess.APublic) && !Lambda.has(access,phase_FieldAccess.APrivate)) {
			access.push(phase_FieldAccess.APublic);
		}
		var name1 = this.consume("[identifier]","Expected an identifier");
		var type = null;
		if(this.match([":"])) {
			type = this.parseTypePath();
		}
		if(this.match(["[newline]"])) {
			this.ignoreNewlines();
			return new phase_Field(name1,phase_FieldKind.FVar(new phase_Var(name1,null),type),access,annotation);
		}
		if(this.match(["="])) {
			if(Lambda.has(access,phase_FieldAccess.AAbstract)) {
				throw new js__$Boot_HaxeError(this.error(this.previous(),"No assignment allowed"));
			}
			this.ignoreNewlines();
			var expr = this.expression();
			this.expectEndOfStatement();
			return new phase_Field(name1,phase_FieldKind.FVar(new phase_Var(name1,expr),type),access,annotation);
		}
		this.consume("(","Expect '(' after function name.");
		var params = this.functionParams(name1.lexeme == "new");
		var ret = this.typeHint();
		var body = null;
		if(Lambda.has(access,phase_FieldAccess.AAbstract)) {
			this.expectEndOfStatement();
		} else {
			this.consume("{","Expect '{' before function body");
			body = this.functionBody();
			this.expectEndOfStatement();
		}
		return new phase_Field(name1,phase_FieldKind.FFun(new phase_Function(name1,params,body,ret,[])),access,annotation);
	}
	,annotationList: function() {
		var _gthis = this;
		var annotation = [];
		while(true) {
			var absolute = false;
			if(this.match(["::"])) {
				absolute = true;
			}
			var path = this.parseList("::",(function() {
				return function() {
					return _gthis.consume("[type-identifier]","Expect a package name seperated by '::'");
				};
			})());
			var params = [];
			if(this.match(["("])) {
				if(!this.check(")")) {
					var visitedNamedParam = [false];
					params = this.parseList(",",(function(visitedNamedParam1) {
						return function() {
							var e = _gthis.expression();
							if(((e) instanceof phase_Assign)) {
								visitedNamedParam1[0] = true;
								return e;
							}
							if(visitedNamedParam1[0]) {
								var params1 = _gthis.previous();
								throw new js__$Boot_HaxeError(_gthis.error(params1,"All unnamed params MUST come before named ones in annotations"));
							}
							return e;
						};
					})(visitedNamedParam));
					this.ignoreNewlines();
				}
				this.consume(")","Expect ')' at the end of metadata entries");
			}
			this.ignoreNewlines();
			annotation.push(new phase_Annotation(path,params,absolute,null));
			if(!this.match(["@"])) {
				break;
			}
		}
		return annotation;
	}
	,throwStatement: function() {
		var value = this.expression();
		this.expectEndOfStatement();
		return new phase_Throw(this.previous(),value);
	}
	,tryStatement: function() {
		this.ignoreNewlines();
		this.consume("{","Expect '{' after 'try'");
		this.ignoreNewlines();
		var body = this.blockStatement();
		var caught = [];
		this.ignoreNewlines();
		while(this.match(["catch"]) && !this.isAtEnd()) {
			this.consume("(","Expect '('");
			var name = this.consume("[identifier]","Expect an identifier");
			var type = this.typeHint();
			this.consume(")","Expect ')'");
			this.consume("{","Expect '{'");
			this.ignoreNewlines();
			var body1 = this.blockStatement();
			caught.push({ name : name, type : type, body : body1});
		}
		return new phase_Try(body,caught);
	}
	,ifStatement: function() {
		this.consume("(","Expect '(' after 'if'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after if condition.");
		var thenBranch = this.statement();
		if(!((thenBranch) instanceof phase_Block)) {
			thenBranch = new phase_Block([thenBranch]);
		}
		var elseBranch = null;
		if(this.match(["else"])) {
			elseBranch = this.statement();
			if(!((elseBranch) instanceof phase_Block)) {
				elseBranch = new phase_Block([elseBranch]);
			}
		}
		return new phase_If(condition,thenBranch,elseBranch);
	}
	,whileStatement: function() {
		this.consume("(","Expect '(' after 'while'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after 'while' condition.");
		var body = this.statement();
		return new phase_While(condition,body);
	}
	,forStatement: function() {
		this.consume("(","Expect '(' after 'for'.");
		var key = this.consume("[identifier]","Expect an identifier");
		var value = null;
		if(this.check(":")) {
			this.advance();
			value = this.consume("[identifier]","Expect an identifier after a colon");
		}
		this.consume("in","Expect `in` after destructuring");
		var target = this.expression();
		this.consume(")","Expect ')'");
		var body = this.statement();
		return new phase_For(key,value,target,body);
	}
	,switchStatement: function() {
		this.consume("(","Expect '(' after 'switch'.");
		this.ignoreNewlines();
		var target = this.expression();
		this.ignoreNewlines();
		this.consume(")","Expect ')' after switch target");
		this.ignoreNewlines();
		this.consume("{","Expect '{'");
		this.ignoreNewlines();
		var cases = [];
		while(!this.isAtEnd() && this.match(["case","default"])) {
			this.ignoreNewlines();
			var condition = null;
			var isDefault = false;
			if(this.previous().type == "default") {
				isDefault = true;
			} else {
				condition = this.expression();
			}
			this.consume(":","Expect a ':' after case condition");
			this.ignoreNewlines();
			var body = [];
			while(!this.isAtEnd() && !this.check("case") && !this.check("default") && !this.check("}")) body.push(this.statement());
			cases.push({ condition : condition, body : body, isDefault : isDefault});
		}
		this.ignoreNewlines();
		this.consume("}","Expect a '}' at the end of switch statement");
		this.ignoreNewlines();
		return new phase_Switch(target,cases);
	}
	,returnStatement: function() {
		var keyword = this.previous();
		var value = null;
		if(!this.check(";") && !this.check("[newline]")) {
			value = this.expression();
		}
		this.expectEndOfStatement();
		return new phase_Return(keyword,value);
	}
	,block: function() {
		this.ignoreNewlines();
		var statements = [];
		while(!this.check("}") && !this.isAtEnd()) statements.push(this.declaration());
		this.ignoreNewlines();
		this.consume("}","Expect '}' at the end of a block.");
		return statements;
	}
	,blockStatement: function() {
		var statements = this.block();
		this.ignoreNewlines();
		return new phase_Block(statements);
	}
	,expressionStatement: function() {
		var expr = this.expression();
		this.expectEndOfStatement();
		return new phase_Expression(expr);
	}
	,expression: function() {
		return this.assignment();
	}
	,assignment: function() {
		var expr = this.or();
		if(this.match(["="])) {
			var equals = this.previous();
			this.ignoreNewlines();
			var value = this.assignment();
			if(((expr) instanceof phase_Variable)) {
				var name = expr.name;
				return new phase_Assign(name,value);
			} else if(((expr) instanceof phase_Get)) {
				var get = expr;
				return new phase_Set(get.object,get.name,value);
			} else if(((expr) instanceof phase_SubscriptGet)) {
				var get1 = expr;
				return new phase_SubscriptSet(this.previous(),get1.object,get1.index,value);
			}
			throw new js__$Boot_HaxeError(this.error(equals,"Invalid assignment target."));
		}
		return expr;
	}
	,or: function() {
		var expr = this.and();
		while(this.match(["||"])) {
			var op = this.previous();
			var right = this.and();
			expr = new phase_Logical(expr,op,right);
		}
		return expr;
	}
	,and: function() {
		var expr = this.equality();
		while(this.match(["&&"])) {
			var op = this.previous();
			var right = this.equality();
			expr = new phase_Logical(expr,op,right);
		}
		return expr;
	}
	,equality: function() {
		var expr = this.comparison();
		while(this.match(["!=","=="])) {
			var op = this.previous();
			var right = this.comparison();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,comparison: function() {
		var expr = this.addition();
		if(this.match(["is"])) {
			var type = this.parseTypePath();
			this.ignoreNewlines();
			return new phase_Is(expr,type);
		}
		while(this.match([">",">=","<","<="])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.addition();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,addition: function() {
		var expr = this.multiplication();
		while(this.match(["-","+","+++"])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.multiplication();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,multiplication: function() {
		var expr = this.range();
		while(this.match(["\\","*"])) {
			var op = this.previous();
			this.ignoreNewlines();
			var right = this.range();
			expr = new phase_Binary(expr,op,right);
		}
		return expr;
	}
	,range: function() {
		var expr = this.pipe();
		while(this.match(["..."])) {
			this.ignoreNewlines();
			var to = this.pipe();
			expr = new phase_Range(expr,to);
		}
		return expr;
	}
	,pipe: function() {
		var expr = this.unary();
		while(this.match(["|>"])) {
			var op = this.previous();
			var target = this.unary();
			switch(target == null ? null : js_Boot.getClass(target)) {
			case phase_Call:
				var caller = target;
				caller.args.push(expr);
				expr = caller;
				break;
			case phase_Lambda:
				expr = new phase_Call(new phase_Grouping(target),op,[expr]);
				break;
			default:
				throw new js__$Boot_HaxeError(this.error(op,"Expected a function/method call or a lambda"));
			}
		}
		return expr;
	}
	,unary: function() {
		if(this.match(["!","-","++","--"])) {
			var op = this.previous();
			this.ignoreNewlines();
			return new phase_Unary(op,this.unary(),true);
		}
		var expr = this.call();
		if(this.match(["++","--"])) {
			var op1 = this.previous();
			return new phase_Unary(op1,expr,false);
		}
		return expr;
	}
	,call: function() {
		var expr = this.primary();
		while(!this.isAtEnd()) {
			this.conditionalIgnoreNewlines();
			if(this.match(["("])) {
				expr = this.finishCall(expr);
			} else if(this.match(["{"])) {
				expr = new phase_Call(expr,this.previous(),[this.shortLambda(!this.check("[newline]"))]);
			} else if(this.match(["."])) {
				this.ignoreNewlines();
				var name;
				if(this.match(["{"])) {
					this.ignoreNewlines();
					var ret = this.expression();
					if(((ret) instanceof phase_Variable)) {
						ret = new phase_Grouping(ret);
					}
					this.ignoreNewlines();
					this.consume("}","Expect a '}'");
					name = ret;
				} else {
					name = this.match(["[type-identifier]","class"]) ? new phase_Variable(this.previous()) : new phase_Variable(this.consume("[identifier]","Expect property name after '.'."));
				}
				expr = new phase_Get(expr,name);
			} else if(this.match(["["])) {
				if(this.match(["]"])) {
					expr = new phase_SubscriptGet(this.previous(),expr,null);
				} else {
					this.ignoreNewlines();
					var index = this.expression();
					this.ignoreNewlines();
					this.consume("]","Expect ']' after expression");
					expr = new phase_SubscriptGet(this.previous(),expr,index);
				}
			} else {
				break;
			}
		}
		return expr;
	}
	,finishCall: function(callee) {
		var $arguments = [];
		if(!this.check(")")) {
			while(true) {
				this.ignoreNewlines();
				$arguments.push(this.expression());
				if(!this.match([","])) {
					break;
				}
			}
		}
		this.ignoreNewlines();
		var paren = this.consume(")","Expect ')' after arguments.");
		if(this.match(["{"])) {
			$arguments.push(this.shortLambda(!this.check("[newline]")));
		}
		return new phase_Call(callee,paren,$arguments);
	}
	,taggedTemplate: function(callee) {
		var firstTok = this.peek();
		var parts = [];
		var placeholders = [];
		if(!this.check("[string]")) {
			while(true) {
				if(this.match(["[interpolation]"])) {
					parts.push(new phase_Literal(this.previous().literal));
				} else {
					placeholders.push(this.expression());
				}
				if(!(!this.check("[string]") && !this.isAtEnd())) {
					break;
				}
			}
		}
		parts.push(this.primary());
		return new phase_Call(callee,firstTok,[new phase_ArrayLiteral(firstTok,parts),new phase_ArrayLiteral(firstTok,placeholders)]);
	}
	,interpolation: function(expr) {
		while(!this.isAtEnd()) {
			var next;
			if(this.match(["[string]"])) {
				return new phase_Binary(expr,new phase_Token("+++","+++",null,this.previous().pos),new phase_Literal(this.previous().literal));
			} else if(this.match(["[interpolation]"])) {
				next = new phase_Literal(this.previous().literal);
			} else {
				next = new phase_Grouping(this.expression());
			}
			expr = new phase_Binary(expr,new phase_Token("+++","+++",null,this.peek().pos),next);
		}
		this.error(this.peek(),"Unexpected end of interpolated string");
		return expr;
	}
	,primary: function() {
		if(this.match(["false"])) {
			return new phase_Literal(false);
		}
		if(this.match(["true"])) {
			return new phase_Literal(true);
		}
		if(this.match(["null"])) {
			return new phase_Literal(null);
		}
		if(this.match(["[number]","[string]"])) {
			return new phase_Literal(this.previous().literal);
		}
		if(this.match(["[interpolation]"])) {
			return this.interpolation(new phase_Literal(this.previous().literal));
		}
		if(this.match(["super"])) {
			var keyword = this.previous();
			this.consume(".","Expect '.' after 'super'.");
			this.ignoreNewlines();
			var method = this.consume("[identifier]","Expect superclass method name.");
			return new phase_Super(keyword,method);
		}
		if(this.match(["this"])) {
			return new phase_This(this.previous());
		}
		if(this.match(["static"])) {
			return new phase_Static(this.previous());
		}
		if(this.match(["::"])) {
			return this.namespacedExprOrType(true);
		}
		if(this.check("[type-identifier]")) {
			return this.namespacedExprOrType(false);
		}
		if(this.match(["[identifier]"])) {
			return new phase_Variable(this.previous());
		}
		if(this.match(["[template]"])) {
			return this.taggedTemplate(new phase_Variable(this.previous()));
		}
		if(this.match(["("])) {
			this.ignoreNewlines();
			var expr = this.expression();
			this.ignoreNewlines();
			this.consume(")","Expect ')' after expression.");
			return new phase_Grouping(expr);
		}
		if(this.match(["["])) {
			return this.arrayOrAssocLiteral();
		}
		if(this.match(["{"])) {
			return this.shortLambda(!this.check("[newline]"));
		}
		if(this.match(["function"])) {
			return new phase_Lambda(this.functionDef(true));
		}
		if(this.match(["if"])) {
			return this.ternary();
		}
		var tok = this.peek();
		throw new js__$Boot_HaxeError(this.error(tok,"Unexpected " + tok.type));
	}
	,namespacedExprOrType: function(isAbsolute) {
		var path = [this.consume("[type-identifier]","Expect at least one type identifier")];
		while(this.check("::") && this.checkNext("[type-identifier]") && !this.isAtEnd()) {
			this.advance();
			path.push(this.advance());
		}
		var type = new phase_Type(path,isAbsolute);
		if(this.match(["::"])) {
			var tok = this.consume("[identifier]","Expect an identifier");
			return new phase_Namespaced(type,tok);
		}
		return type;
	}
	,ternary: function() {
		this.consume("(","Expect '(' after 'if'.");
		var condition = this.expression();
		this.consume(")","Expect ')' after if condition.");
		this.ignoreNewlines();
		var thenBranch = this.expression();
		this.ignoreNewlines();
		this.consume("else","Expected an 'else' branch");
		this.ignoreNewlines();
		var elseBranch = this.expression();
		return new phase_Ternary(condition,thenBranch,elseBranch);
	}
	,arrayOrAssocLiteral: function() {
		this.ignoreNewlines();
		if(this.checkNext(":")) {
			return this.assocArrayLiteral();
		}
		return this.arrayLiteral();
	}
	,arrayLiteral: function() {
		var values = [];
		if(!this.check("]")) {
			values = this.parseList(",",$bind(this,this.expression));
		}
		this.ignoreNewlines();
		var end = this.consume("]","Expect ']' after values.");
		return new phase_ArrayLiteral(end,values);
	}
	,assocArrayLiteral: function() {
		var keys = [];
		var values = [];
		if(!this.check("]")) {
			while(true) {
				this.ignoreNewlines();
				keys.push(this.expression());
				this.consume(":","Expect colons after object keys");
				this.ignoreNewlines();
				values.push(this.expression());
				if(!this.match([","])) {
					break;
				}
			}
			this.ignoreNewlines();
		}
		var end = this.consume("]","Expect ']' at the end of an assoc array literal");
		return new phase_AssocArrayLiteral(end,keys,values);
	}
	,shortLambda: function(isInline) {
		if(isInline == null) {
			isInline = false;
		}
		this.ignoreNewlines();
		var params = [];
		var maybeNeedIt = false;
		if(this.match(["|"])) {
			if(!this.check("|")) {
				while(true) {
					params.push({ name : this.consume("[identifier]","Expect parameter name"), type : null, expr : null});
					if(!this.match([","])) {
						break;
					}
				}
			}
			this.consume("|","Expect '|' after parameters");
			isInline = !this.check("[newline]");
		} else {
			params = [{ name : new phase_Token("[identifier]","it",null,this.previous().pos), type : null, expr : new phase_Literal(null)}];
		}
		var body = [];
		if(isInline && !this.check("return")) {
			body.push(new phase_Return(this.peek(),this.expression()));
			this.ignoreNewlines();
			this.consume("}","Inline lambdas must contain only one expression.");
		} else {
			body = this.block();
		}
		return new phase_Lambda(new phase_Function(new phase_Token("[identifier]","",null,this.previous().pos),params,new phase_Block(body),null,[]));
	}
	,typeHint: function() {
		if(this.match([":"])) {
			return this.parseTypePath();
		}
		return null;
	}
	,parseTypePath: function() {
		var _gthis = this;
		var absolute = this.match(["::"]);
		var path = this.parseList("::",function() {
			return _gthis.consume("[type-identifier]","Expect a TypeIdentifier");
		});
		return new phase_Type(path,absolute);
	}
	,tempVar: function(prefix) {
		this.uid++;
		return "" + prefix + "_" + this.uid;
	}
	,synchronize: function() {
		this.advance();
		while(!this.isAtEnd()) {
			if(this.previous().type == ";") {
				return;
			}
			if(this.previous().type == "[newline]") {
				return;
			}
			switch(this.peek().type) {
			case "class":case "for":case "function":case "if":case "return":case "switch":case "var":case "while":
				return;
			default:
				this.advance();
			}
		}
	}
	,parseList: function(sep,parser) {
		var items = [];
		while(true) {
			this.ignoreNewlines();
			items.push(parser());
			if(!(this.match([sep]) && !this.isAtEnd())) {
				break;
			}
		}
		return items;
	}
	,conditionalIgnoreNewlines: function() {
		var _gthis = this;
		if(this.check("[newline]")) {
			while(!this.isAtEnd()) {
				if(this.checkNext("[newline]")) {
					this.advance();
				}
				if(Lambda.exists(phase_Parser.continuationTokens,function(f) {
					return _gthis.checkNext(f);
				})) {
					this.advance();
					return;
				}
				if(!this.checkNext("[newline]")) {
					return;
				}
			}
		}
	}
	,ignoreNewlines: function() {
		while(!this.isAtEnd()) if(!this.match(["[newline]"])) {
			return;
		}
	}
	,expectEndOfStatement: function() {
		if(this.check("}")) {
			return true;
		}
		if(this.match(["[newline]","[eof]"])) {
			this.ignoreNewlines();
			return true;
		}
		this.consume(";","Expect newline or semicolon after statement");
		this.ignoreNewlines();
		return false;
	}
	,match: function(types) {
		var _g = 0;
		while(_g < types.length) {
			var type = types[_g];
			++_g;
			if(this.check(type)) {
				this.advance();
				return true;
			}
		}
		return false;
	}
	,consume: function(type,message) {
		if(this.check(type)) {
			return this.advance();
		}
		throw new js__$Boot_HaxeError(this.error(this.peek(),message));
	}
	,check: function(type) {
		if(this.isAtEnd()) {
			return false;
		}
		return this.peek().type == type;
	}
	,checkNext: function(type) {
		if(this.isAtEnd()) {
			return false;
		}
		return this.peekNext().type == type;
	}
	,advance: function() {
		if(!this.isAtEnd()) {
			this.current++;
		}
		return this.previous();
	}
	,peek: function() {
		return this.tokens[this.current];
	}
	,peekNext: function() {
		return this.tokens[this.current + 1];
	}
	,previous: function() {
		return this.tokens[this.current - 1];
	}
	,isAtEnd: function() {
		return this.peek().type == "[eof]";
	}
	,error: function(token,message) {
		this.reporter.report(token.pos,token.lexeme,message);
		return new phase_ParserError();
	}
	,__class__: phase_Parser
};
var phase_ParserError = function() {
};
phase_ParserError.__name__ = true;
phase_ParserError.prototype = {
	__class__: phase_ParserError
};
var phase_GeneratorMode = $hxEnums["phase.GeneratorMode"] = { __ename__ : true, __constructs__ : ["GeneratingRoot","GeneratingClass","GeneratingInterface","GeneratingTrait","GeneratingClosure","GeneratingFunction"]
	,GeneratingRoot: {_hx_index:0,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingClass: {_hx_index:1,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingInterface: {_hx_index:2,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingTrait: {_hx_index:3,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingClosure: {_hx_index:4,__enum__:"phase.GeneratorMode",toString:$estr}
	,GeneratingFunction: {_hx_index:5,__enum__:"phase.GeneratorMode",toString:$estr}
};
var phase_StmtVisitor = function() { };
phase_StmtVisitor.__name__ = true;
phase_StmtVisitor.prototype = {
	__class__: phase_StmtVisitor
};
var phase_PhpGenerator = function(stmts,reporter,options) {
	this.exprKind = new haxe_ds_ObjectMap();
	this.append = [];
	this.uid = 0;
	this.indentLevel = 0;
	this.closureCaptures = [];
	this.mode = phase_GeneratorMode.GeneratingRoot;
	this.options = options == null ? { } : options;
	this.stmts = stmts;
	this.reporter = reporter;
	if(this.options.annotation == null) {
		this.options.annotation = "on-class";
	}
};
phase_PhpGenerator.__name__ = true;
phase_PhpGenerator.__interfaces__ = [phase_ExprVisitor,phase_StmtVisitor];
phase_PhpGenerator.prototype = {
	generate: function() {
		this.append = [];
		this.exprKind = new haxe_ds_ObjectMap();
		this.scope = new phase_PhpScope();
		var out = [];
		var _g = 0;
		var _g1 = this.stmts;
		while(_g < _g1.length) {
			var stmt = _g1[_g];
			++_g;
			var s = this.generateStmt(stmt);
			if(s != null && s != "") {
				out.push(s);
			}
		}
		return "<?php\n" + out.concat(this.append).join("\n");
	}
	,generateStmt: function(stmt) {
		if(stmt == null) {
			return "";
		}
		return stmt.accept(this);
	}
	,generateExpr: function(expr) {
		if(expr == null) {
			return "";
		}
		return expr.accept(this);
	}
	,visitPackageStmt: function(stmt) {
		var _gthis = this;
		var out = "namespace " + stmt.path.map(function(t) {
			return t.lexeme;
		}).join("\\") + " {\n\n";
		this.scope.push();
		this.indent();
		out += stmt.decls.map($bind(this,this.generateStmt)).join("\n");
		this.scope.pop();
		if(this.append.length > 0) {
			out += "\n\n" + this.append.map(function(a) {
				return _gthis.getIndent() + a;
			}).join("\n");
			this.append = [];
		}
		this.outdent();
		return out + "\n\n" + this.getIndent() + "}";
	}
	,visitBlockStmt: function(stmt) {
		var out = this.getIndent() + "{\n";
		this.scope.push();
		this.indent();
		out += stmt.statements.map($bind(this,this.generateStmt)).join("\n") + "\n";
		this.outdent();
		this.scope.pop();
		out += this.getIndent() + "}";
		return out;
	}
	,visitExpressionStmt: function(stmt) {
		return this.getIndent() + this.generateExpr(stmt.expression) + ";";
	}
	,visitIfStmt: function(stmt) {
		var out = this.getIndent() + "if (" + this.generateExpr(stmt.condition) + ")\n" + this.generateStmt(stmt.thenBranch);
		if(stmt.elseBranch != null) {
			out += "\n" + this.getIndent() + "else\n" + this.generateStmt(stmt.elseBranch);
		}
		return out;
	}
	,visitReturnStmt: function(stmt) {
		return this.getIndent() + (stmt.value == null ? "return;" : "return " + this.generateExpr(stmt.value) + ";");
	}
	,visitVarStmt: function(stmt) {
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpVar);
		return this.getIndent() + "$" + this.safeVar(stmt.name) + " = " + (stmt.initializer != null ? this.generateExpr(stmt.initializer) : "null") + ";";
	}
	,visitGlobalStmt: function(stmt) {
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpVar);
		return this.getIndent() + "global $" + this.safeVar(stmt.name) + ";";
	}
	,visitUseStmt: function(stmt) {
		var _gthis = this;
		var path = stmt.path.map(function(t) {
			return t.lexeme;
		}).join("\\");
		if(stmt.absolute) {
			path = "\\" + path;
		}
		var _g = stmt.kind;
		switch(_g._hx_index) {
		case 0:
			var name = stmt.path[stmt.path.length - 1].lexeme;
			this.scope.define(name,phase_PhpKind.PhpType);
			return this.getIndent() + ("use " + path + ";");
		case 1:
			var target = _g.alias;
			switch(target._hx_index) {
			case 0:
				var alias = target.name;
				this.scope.define(alias.lexeme,phase_PhpKind.PhpType);
				return this.getIndent() + ("use " + path + " as " + alias.lexeme + ";");
			case 1:
				var alias1 = target.name;
				this.scope.define(alias1.lexeme,phase_PhpKind.PhpFun);
				return this.getIndent() + ("use function " + path + " as " + alias1.lexeme + ";");
			}
			break;
		case 2:
			var items = _g.items;
			return items.map(function(target1) {
				switch(target1._hx_index) {
				case 0:
					var f = target1.name;
					_gthis.scope.define(f.lexeme,phase_PhpKind.PhpType);
					return _gthis.getIndent() + ("use " + path + "\\" + f.lexeme + ";");
				case 1:
					var f1 = target1.name;
					_gthis.scope.define(f1.lexeme,phase_PhpKind.PhpFun);
					return _gthis.getIndent() + ("use function " + path + "\\" + f1.lexeme + ";");
				}
			}).join("\n");
		}
	}
	,visitClassStmt: function(stmt) {
		var out = "";
		if(stmt.annotation.length > 0) {
			out += this.generateAnnotations({ cls : stmt},stmt.annotation);
		}
		var keyword;
		switch(stmt.kind._hx_index) {
		case 0:
			keyword = "class";
			break;
		case 1:
			keyword = "interface";
			break;
		case 2:
			keyword = "trait";
			break;
		}
		out += "\n" + this.getIndent() + keyword + " " + stmt.name.lexeme;
		this.scope.define(stmt.name.lexeme,phase_PhpKind.PhpType);
		if(stmt.superclass != null) {
			out += " extends " + stmt.superclass.lexeme;
		}
		if(stmt.interfaces.length > 0) {
			var out1;
			switch(stmt.kind._hx_index) {
			case 0:
				out1 = " implements ";
				break;
			case 1:
				out1 = " extends ";
				break;
			case 2:
				out1 = "";
				break;
			}
			out += out1;
			out += stmt.interfaces.map(function(t) {
				return t.lexeme;
			}).join(", ");
		}
		out += "\n" + this.getIndent() + "{\n";
		this.indent();
		this.scope.push();
		var prevMode = this.mode;
		var tmp;
		switch(stmt.kind._hx_index) {
		case 0:
			tmp = phase_GeneratorMode.GeneratingClass;
			break;
		case 1:
			tmp = phase_GeneratorMode.GeneratingInterface;
			break;
		case 2:
			tmp = phase_GeneratorMode.GeneratingTrait;
			break;
		}
		this.mode = tmp;
		var _g2 = 0;
		var _g3 = stmt.fields;
		while(_g2 < _g3.length) {
			var field = _g3[_g2];
			++_g2;
			if(field.annotation.length > 0) {
				out += this.generateAnnotations({ cls : stmt, field : field.name.lexeme},field.annotation);
			}
			out += this.generateStmt(field) + "\n";
		}
		this.mode = prevMode;
		this.scope.pop();
		this.outdent();
		return out + "\n" + this.getIndent() + "}";
	}
	,visitFieldStmt: function(stmt) {
		var _gthis = this;
		var isConst = false;
		var tmp = "\n" + this.getIndent() + stmt.access.map(function(a) {
			switch(a._hx_index) {
			case 0:
				return "static";
			case 1:
				return "public";
			case 2:
				return "protected";
			case 3:
				if(_gthis.mode == phase_GeneratorMode.GeneratingInterface) {
					return null;
				} else {
					return "abstract";
				}
				break;
			case 4:
				isConst = true;
				return "const";
			}
		}).filter(function(f) {
			return f != null;
		}).join(" ");
		var _g = stmt.kind;
		var tmp1;
		switch(_g._hx_index) {
		case 0:
			var type = _g.type;
			tmp1 = "use " + this.generateTypePath(type) + ";";
			break;
		case 1:
			var v = _g.v;
			var out = isConst ? " " + this.safeVar(stmt.name) : " $" + this.safeVar(stmt.name);
			if(v.initializer != null) {
				out += " = " + this.generateExpr(v.initializer);
			}
			tmp1 = out + ";";
			break;
		case 2:
			var fun = _g.fun;
			var name = stmt.name.lexeme == "new" ? "__construct" : this.safeVar(stmt.name);
			this.scope.push();
			var out1 = " function " + name + "(" + this.functionParams(fun.params) + ")";
			if(stmt.access.indexOf(phase_FieldAccess.AAbstract) < 0) {
				var body = fun.body;
				var _g1 = 0;
				var _g11 = fun.params;
				while(_g1 < _g11.length) {
					var p = _g11[_g1];
					++_g1;
					if(p.isInit == true) {
						var init = new phase_Expression(new phase_Set(new phase_This(p.name),new phase_Variable(p.name),new phase_Variable(p.name)));
						body.statements.unshift(init);
					}
				}
				out1 += "\n" + this.generateStmt(body);
			} else {
				out1 += ";";
			}
			this.scope.pop();
			tmp1 = out1;
			break;
		}
		return tmp + tmp1;
	}
	,visitFunctionStmt: function(stmt) {
		this.scope.define(this.safeVar(stmt.name),phase_PhpKind.PhpFun);
		this.scope.push();
		var prevMode = this.mode;
		this.mode = phase_GeneratorMode.GeneratingFunction;
		var out = "\n" + this.getIndent() + "function " + this.safeVar(stmt.name) + "(" + this.functionParams(stmt.params) + ")\n";
		out += this.generateStmt(stmt.body);
		this.mode = prevMode;
		this.scope.pop();
		return out;
	}
	,functionParams: function(params) {
		var _gthis = this;
		return params.map(function(param) {
			var name = _gthis.safeVar(param.name);
			_gthis.scope.define(name,phase_PhpKind.PhpVar);
			var out = param.type != null ? _gthis.generateTypePath(param.type) + " $" + name : "$" + name;
			if(param.expr != null) {
				out += " = " + _gthis.generateExpr(param.expr);
			}
			return out;
		}).join(", ");
	}
	,visitThrowStmt: function(stmt) {
		return this.getIndent() + "throw " + this.generateExpr(stmt.expr) + ";";
	}
	,visitTryStmt: function(stmt) {
		var out = this.getIndent() + "try\n";
		out += this.generateStmt(stmt.body);
		var _g = 0;
		var _g1 = stmt.catches;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			this.scope.push();
			var name = this.safeVar(c.name);
			this.scope.define(name,phase_PhpKind.PhpVar);
			out += "\n" + this.getIndent() + "catch (";
			if(c.type != null) {
				out += this.generateTypePath(c.type) + " $" + name + ")\n";
			} else {
				out += "$" + name + ")\n";
			}
			out += this.generateStmt(c.body);
			this.scope.pop();
		}
		return out;
	}
	,visitWhileStmt: function(stmt) {
		return this.getIndent() + "while (" + this.generateExpr(stmt.condition) + ")\n" + this.generateStmt(stmt.body);
	}
	,visitForStmt: function(stmt) {
		var o = stmt.target;
		if((o == null ? null : js_Boot.getClass(o)) == phase_Range) {
			this.scope.push();
			var range = stmt.target;
			var key = this.safeVar(stmt.key);
			var init = this.generateExpr(range.from);
			var limit = this.generateExpr(range.to);
			this.scope.define(key,phase_PhpKind.PhpVar);
			var out = this.getIndent() + "for ($" + key + " = " + init + ";" + " $" + key + " < " + limit + "; $" + key + "++)\n" + this.generateStmt(stmt.body);
			this.scope.pop();
			return out;
		} else {
			this.scope.push();
			var key1 = this.safeVar(stmt.key);
			var out1 = this.getIndent() + "foreach (" + this.generateExpr(stmt.target) + " as $" + key1;
			this.scope.define(key1,phase_PhpKind.PhpVar);
			if(stmt.value != null) {
				var value = this.safeVar(stmt.value);
				this.scope.define(value,phase_PhpKind.PhpVar);
				out1 += " => $" + value;
			}
			out1 += ")\n" + this.generateStmt(stmt.body);
			this.scope.pop();
			return out1;
		}
	}
	,visitSwitchStmt: function(stmt) {
		var out = this.getIndent() + "switch (" + this.generateExpr(stmt.target) + ")\n" + this.getIndent() + "{\n";
		this.indent();
		var _g = 0;
		var _g1 = stmt.cases;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isDefault) {
				out += this.getIndent() + "default:\n";
			} else {
				out += this.getIndent() + "case " + this.generateExpr(c.condition) + ":\n";
			}
			this.indent();
			out += c.body.map($bind(this,this.generateStmt)).join("") + "\n";
			out += this.getIndent() + "break;\n";
			this.outdent();
		}
		this.outdent();
		out += this.getIndent() + "}";
		return out;
	}
	,visitAnnotationExpr: function(expr) {
		var _gthis = this;
		var name = expr.path.map(function(t) {
			return t.lexeme;
		}).join("\\");
		switch(this.options.annotation) {
		case "docblock":
			return "@" + name + "(" + expr.params.map(function(param) {
				if((param == null ? null : js_Boot.getClass(param)) == phase_Assign) {
					var assign = param;
					return "" + assign.name.lexeme + " = " + _gthis.generateExpr(assign.value);
				} else {
					return _gthis.generateExpr(param);
				}
			}).join(", ") + ")";
		case "on-class":case "phase":
			var tmp = this.tempVar("annotation");
			var args = [];
			this.indent();
			var out = "";
			var _g = 0;
			var _g1 = expr.params;
			while(_g < _g1.length) {
				var param1 = _g1[_g];
				++_g;
				if((param1 == null ? null : js_Boot.getClass(param1)) == phase_Assign) {
					var assign1 = param1;
					out += this.getIndent() + "$" + tmp + "->" + assign1.name.lexeme + " = " + this.generateExpr(assign1.value) + ";\n";
				} else {
					args.push(this.generateExpr(param1));
				}
			}
			out = this.getIndent() + "$" + tmp + " = new " + name + "(" + args.join(", ") + ");\n" + out;
			out += this.getIndent() + "return $" + tmp + ";\n";
			this.outdent();
			return "(function () {\n" + out + this.getIndent() + "})()";
		}
	}
	,visitArrayLiteralExpr: function(expr) {
		return "[" + this.generateList(expr.values) + "]";
	}
	,visitAssocArrayLiteralExpr: function(expr) {
		this.indent();
		var _g = [];
		var _g1 = 0;
		var _g2 = expr.keys.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var key = expr.keys[i];
			var value = expr.values[i];
			_g.push(this.getIndent() + ("" + this.generateExpr(key) + " => " + this.generateExpr(value)));
		}
		var out = "[\n" + _g.join(",\n");
		this.outdent();
		return out + "\n" + this.getIndent() + "]";
	}
	,visitAssignExpr: function(expr) {
		var name = this.safeVar(expr.name);
		var kind = this.scope.get(name);
		if(kind != phase_PhpKind.PhpVar) {
			throw new js__$Boot_HaxeError(this.error(expr.name,"Invalid assignment"));
		}
		return "$" + name + (" = " + this.generateExpr(expr.value));
	}
	,visitIsExpr: function(expr) {
		return this.generateExpr(expr.left) + " instanceof " + this.generateExpr(expr.type);
	}
	,visitBinaryExpr: function(expr) {
		var op = expr.op.type == "+++" ? "." : expr.op.lexeme;
		return this.generateExpr(expr.left) + " " + op + " " + this.generateExpr(expr.right);
	}
	,visitCallExpr: function(expr) {
		var callee;
		var o = expr.callee;
		switch(o == null ? null : js_Boot.getClass(o)) {
		case phase_Get:
			var getter = expr.callee;
			var o1 = getter.object;
			switch(o1 == null ? null : js_Boot.getClass(o1)) {
			case phase_Static:case phase_Type:
				callee = this.generateExpr(getter.object) + "::" + this.getProperty(getter.name);
				break;
			default:
				callee = this.generateExpr(getter.object) + "->" + this.getProperty(getter.name);
			}
			break;
		case phase_Type:
			callee = "new " + this.generateExpr(expr.callee);
			break;
		default:
			callee = this.generateExpr(expr.callee);
		}
		return "" + callee + "(" + expr.args.map($bind(this,this.generateExpr)).join(", ") + ")";
	}
	,visitGetExpr: function(expr) {
		var o = expr.object;
		switch(o == null ? null : js_Boot.getClass(o)) {
		case phase_Static:case phase_Type:
			return this.generateExpr(expr.object) + "::" + this.getProperty(expr.name,true);
		default:
			return this.generateExpr(expr.object) + "->" + this.getProperty(expr.name);
		}
	}
	,visitSetExpr: function(expr) {
		var left;
		var o = expr.object;
		switch(o == null ? null : js_Boot.getClass(o)) {
		case phase_Static:case phase_Type:
			left = this.generateExpr(expr.object) + "::" + this.getProperty(expr.name,true);
			break;
		default:
			left = this.generateExpr(expr.object) + "->" + this.getProperty(expr.name);
		}
		return left + " = " + this.generateExpr(expr.value);
	}
	,getProperty: function(expr,isStatic) {
		if(isStatic == null) {
			isStatic = false;
		}
		if((expr == null ? null : js_Boot.getClass(expr)) == phase_Variable) {
			var e = expr;
			switch(e.name.type) {
			case "[type-identifier]":
				return this.safeVar(e.name);
			case "class":
				return "class";
			default:
				if(isStatic) {
					return "$" + this.safeVar(e.name);
				} else {
					return this.safeVar(e.name);
				}
			}
		} else {
			return "{" + this.generateExpr(expr) + "}";
		}
	}
	,visitSubscriptGetExpr: function(expr) {
		if(expr.index == null) {
			return this.generateExpr(expr.object) + "[]";
		}
		return this.generateExpr(expr.object) + "[" + this.generateExpr(expr.index) + "]";
	}
	,visitSubscriptSetExpr: function(expr) {
		var left = expr.index == null ? this.generateExpr(expr.object) + "[]" : this.generateExpr(expr.object) + "[" + this.generateExpr(expr.index) + "]";
		return left + " = " + this.generateExpr(expr.value);
	}
	,visitGroupingExpr: function(expr) {
		return "(" + this.generateExpr(expr.expression) + ")";
	}
	,visitLambdaExpr: function(expr) {
		var _gthis = this;
		var func = expr.func;
		var prevCaptures = this.closureCaptures;
		var prevMode = this.mode;
		var prevDepth = this.localDepth;
		this.closureCaptures = this.closureCaptures.slice();
		this.mode = phase_GeneratorMode.GeneratingClosure;
		this.scope.push();
		this.localDepth = this.scope.getTop().depth;
		var out = "function (" + this.functionParams(func.params) + ")";
		var body = this.generateStmt(func.body);
		if(this.closureCaptures.length > 0) {
			var uniq = [];
			var _g = 0;
			var _g1 = this.closureCaptures;
			while(_g < _g1.length) {
				var name = _g1[_g];
				++_g;
				if(uniq.indexOf(name) < 0) {
					uniq.push(name);
				}
			}
			out += " use (" + uniq.map(function(n) {
				return "$" + n;
			}).join(", ") + ")";
		}
		out += "\n" + body;
		this.localDepth = prevDepth;
		this.scope.pop();
		this.mode = prevMode;
		if(prevMode._hx_index == 4) {
			this.closureCaptures = prevCaptures.concat(this.closureCaptures.filter(function(name1) {
				return !_gthis.isLocal(name1);
			}));
		} else {
			this.closureCaptures = [];
		}
		return out;
	}
	,visitNamespacedExpr: function(expr) {
		return this.generateExpr(expr.type) + "\\" + this.safeVar(expr.name);
	}
	,visitTernaryExpr: function(expr) {
		return this.generateExpr(expr.condition) + " ? " + this.generateExpr(expr.thenBranch) + " : " + this.generateExpr(expr.elseBranch);
	}
	,visitLiteralExpr: function(expr) {
		if(js_Boot.__instanceof(expr.value,Int)) {
			return expr.value;
		} else if(typeof(expr.value) == "boolean") {
			return expr.value;
		} else if(expr.value == null) {
			return "null";
		} else {
			var value = expr.value;
			return "\"" + StringTools.replace(value,"\"","\\\"") + "\"";
		}
	}
	,visitLogicalExpr: function(expr) {
		return this.generateExpr(expr.left) + " " + expr.op.lexeme + " " + this.generateExpr(expr.right);
	}
	,visitSuperExpr: function(expr) {
		var method = expr.method.lexeme;
		if(method == "new") {
			method = "__construct";
		}
		return "parent::" + method;
	}
	,visitThisExpr: function(expr) {
		return "$this";
	}
	,visitStaticExpr: function(expr) {
		return "static";
	}
	,visitTypeExpr: function(expr) {
		return this.generateTypePath(expr);
	}
	,visitUnaryExpr: function(expr) {
		if(expr.right) {
			return expr.op.lexeme + this.generateExpr(expr.expr);
		} else {
			return this.generateExpr(expr.expr) + expr.op.lexeme;
		}
	}
	,visitRangeExpr: function(expr) {
		return "range(" + this.generateExpr(expr.from) + "," + this.generateExpr(expr.to) + ")";
	}
	,visitVariableExpr: function(expr) {
		var name = this.safeVar(expr.name);
		var kind = this.scope.get(name);
		if(kind == null) {
			kind = phase_PhpKind.PhpFun;
		} else if(this.mode == phase_GeneratorMode.GeneratingClosure) {
			if(!this.isLocal(name) && kind != phase_PhpKind.PhpFun) {
				this.closureCaptures.push(name);
			}
		}
		if(kind._hx_index == 2) {
			return "$" + name;
		} else {
			return name;
		}
	}
	,generateTypePath: function(t) {
		var type = t.path.map(function(t1) {
			return t1.lexeme;
		}).join("\\");
		var _this = phase_PhpGenerator.typeAliases;
		if(__map_reserved[type] != null ? _this.existsReserved(type) : _this.h.hasOwnProperty(type)) {
			var _this1 = phase_PhpGenerator.typeAliases;
			return __map_reserved[type] != null ? _this1.getReserved(type) : _this1.h[type];
		}
		if(t.absolute) {
			type = "\\" + type;
		}
		return type;
	}
	,generateAnnotations: function(target,annotations) {
		var clsName = target.cls.name.lexeme;
		if(this.options.annotation == "on-class") {
			if(!Lambda.exists(target.cls.fields,function(f) {
				return f.name.lexeme == "__annotations__";
			})) {
				var pos = target.cls.name.pos;
				var tok = new phase_Token("[identifier]","__annotations__","",pos);
				target.cls.fields.push(new phase_Field(tok,phase_FieldKind.FVar(new phase_Var(tok,new phase_ArrayLiteral(tok,[])),null),[phase_FieldAccess.APublic,phase_FieldAccess.AStatic],[]));
			}
		}
		switch(this.options.annotation) {
		case "docblock":
			var out = "\n" + this.getIndent() + "/**";
			var _g = 0;
			while(_g < annotations.length) {
				var a = annotations[_g];
				++_g;
				out += "\n" + this.getIndent() + " * " + this.generateExpr(a);
			}
			out += "\n" + this.getIndent() + " */";
			return out;
		case "on-class":
			var kind = target.field == null ? "__CLASS__" : target.field;
			var reg = "" + clsName + "::$" + "__annotations__[\"" + kind + "\"] = " + this.visitArrayLiteralExpr(new phase_ArrayLiteral(target.cls.name,annotations)) + ";";
			this.append.push(reg);
			return "";
		case "phase":
			var kind1 = target.field == null ? "__CLASS__" : target.field;
			var reg1 = "\\Phase\\Boot::registerAnnotation(" + clsName + "::class, \"" + kind1 + "\", " + this.visitArrayLiteralExpr(new phase_ArrayLiteral(target.cls.name,annotations)) + ");";
			this.append.push(reg1);
			return "";
		}
	}
	,generateList: function(items) {
		return items.map($bind(this,this.generateExpr)).join(", ");
	}
	,safeVar: function(tok) {
		var name = tok.lexeme;
		return name;
	}
	,isLocal: function(name) {
		if(this.localDepth != null) {
			var locals = this.scope.getAt(this.localDepth);
			if(locals == null) {
				return false;
			}
			return locals.get(name) != null;
		}
		return this.scope.getTop().get(name) != null;
	}
	,tempVar: function(prefix) {
		this.uid++;
		return "__" + prefix + "_" + this.uid;
	}
	,getIndent: function() {
		var out = "";
		var _g = 0;
		var _g1 = this.indentLevel;
		while(_g < _g1) {
			var i = _g++;
			out += "  ";
		}
		return out;
	}
	,indent: function() {
		this.indentLevel++;
		return this;
	}
	,outdent: function() {
		this.indentLevel--;
		if(this.indentLevel < 0) {
			this.indentLevel = 0;
		}
		return this;
	}
	,error: function(token,message) {
		this.reporter.report(token.pos,token.lexeme,message);
		return new phase_GeneratorError();
	}
	,__class__: phase_PhpGenerator
};
var phase_GeneratorError = function() {
};
phase_GeneratorError.__name__ = true;
phase_GeneratorError.prototype = {
	__class__: phase_GeneratorError
};
var phase_PhpKind = $hxEnums["phase.PhpKind"] = { __ename__ : true, __constructs__ : ["PhpType","PhpFun","PhpVar"]
	,PhpType: {_hx_index:0,__enum__:"phase.PhpKind",toString:$estr}
	,PhpFun: {_hx_index:1,__enum__:"phase.PhpKind",toString:$estr}
	,PhpVar: {_hx_index:2,__enum__:"phase.PhpKind",toString:$estr}
};
var phase_PhpScope = function(enclosing) {
	this.values = new haxe_ds_StringMap();
	this.enclosing = enclosing;
	this.depth = enclosing != null ? enclosing.depth + 1 : 0;
};
phase_PhpScope.__name__ = true;
phase_PhpScope.prototype = {
	getTop: function() {
		if(this.next != null) {
			return this.next.getTop();
		}
		return this;
	}
	,push: function() {
		if(this.next != null) {
			this.next.push();
		} else {
			this.next = new phase_PhpScope(this);
		}
	}
	,pop: function() {
		if(this.next != null && this.next.next != null) {
			return this.next.pop();
		}
		var scope = this.next;
		this.next = null;
		return scope;
	}
	,get: function(key) {
		var value = null;
		if(this.next != null) {
			value = this.next.get(key);
		}
		if(value == null) {
			var _this = this.values;
			if(__map_reserved[key] != null) {
				return _this.getReserved(key);
			} else {
				return _this.h[key];
			}
		}
		return value;
	}
	,define: function(key,value) {
		if(this.next != null) {
			this.next.define(key,value);
			return;
		}
		var _this = this.values;
		if(__map_reserved[key] != null) {
			_this.setReserved(key,value);
		} else {
			_this.h[key] = value;
		}
	}
	,getAt: function(depth) {
		if(depth == this.depth) {
			return this;
		}
		if(this.next != null) {
			return this.next.getAt(depth);
		}
		return null;
	}
	,__class__: phase_PhpScope
};
var phase_Scanner = function(source,file,reporter) {
	this.source = source;
	this.file = file;
	this.reporter = reporter;
};
phase_Scanner.__name__ = true;
phase_Scanner.prototype = {
	scan: function() {
		this.tokens = [];
		this.start = 0;
		this.current = 0;
		this.line = 1;
		while(!this.isAtEnd()) {
			this.start = this.current;
			this.scanToken();
		}
		this.tokens.push(new phase_Token("[eof]","",null,{ line : this.line, offset : this.current, file : this.file}));
		return this.tokens;
	}
	,scanToken: function() {
		var c = this.advance();
		switch(c) {
		case "\t":case "\r":case " ":
			break;
		case "\n":
			this.newline();
			break;
		case "!":
			this.addToken(this.match("=") ? "!=" : "!");
			break;
		case "\"":
			this.string();
			break;
		case "#":
			this.addToken("#");
			break;
		case "&":
			this.addToken(this.match("&") ? "&&" : "&");
			break;
		case "'":
			this.string("'");
			break;
		case "(":
			this.addToken("(");
			break;
		case ")":
			this.addToken(")");
			break;
		case "*":
			this.addToken("*");
			break;
		case "+":
			if(this.match("=")) {
				this.addToken("+=");
			} else if(this.match("+")) {
				this.addToken(this.match("+") ? "+++" : "++");
			} else {
				this.addToken("+");
			}
			break;
		case ",":
			this.addToken(",");
			break;
		case "-":
			this.addToken(this.match("-") ? "--" : "-");
			break;
		case ".":
			this.addToken(this.match(".") ? "..." : ".");
			break;
		case "/":
			if(this.match("/")) {
				while(this.peek() != "\n" && !this.isAtEnd()) this.advance();
				if(this.peek() == "\n") {
					this.line++;
					this.advance();
				}
			} else {
				this.addToken("\\");
			}
			break;
		case ":":
			this.addToken(this.match(":") ? "::" : ":");
			break;
		case ";":
			this.addToken(";");
			break;
		case "<":
			this.addToken(this.match("=") ? "<=" : "<");
			break;
		case "=":
			this.addToken(this.match("=") ? "==" : "=");
			break;
		case ">":
			this.addToken(this.match("=") ? ">=" : ">");
			break;
		case "@":
			this.addToken("@");
			break;
		case "[":
			this.addToken("[");
			break;
		case "]":
			this.addToken("]");
			break;
		case "{":
			this.addToken("{");
			break;
		case "|":
			this.addToken(this.match("|") ? "||" : this.match(">") ? "|>" : "|");
			break;
		case "}":
			this.addToken("}");
			break;
		default:
			if(this.isDigit(c)) {
				this.number();
			} else if(this.isUcAlpha(c)) {
				this.typeIdentifier();
			} else if(this.isAlpha(c)) {
				this.identifier();
			} else {
				this.reporter.report({ line : this.line, offset : this.current, file : this.file},c,"Unexpected character: " + c);
			}
		}
	}
	,typeIdentifier: function() {
		while(this.isAlphaNumeric(this.peek())) this.advance();
		this.addToken("[type-identifier]");
	}
	,identifier: function() {
		while(this.isAlphaNumeric(this.peek())) this.advance();
		var text = this.source.substring(this.start,this.current);
		var _this = phase_Scanner.keywords;
		var type = __map_reserved[text] != null ? _this.getReserved(text) : _this.h[text];
		if((this.peek() == "\"" || this.peek() == "'") && type == null) {
			type = "[template]";
		}
		if(type != null) {
			this.addToken(type);
		} else {
			this.addToken("[identifier]");
		}
	}
	,newline: function() {
		this.line++;
		while(this.peek() == "\n" && !this.isAtEnd()) {
			this.line++;
			this.advance();
		}
		this.addToken("[newline]");
	}
	,string: function(quote,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(quote == null) {
			quote = "\"";
		}
		while(this.peek() != quote && !this.isAtEnd()) {
			if(this.peek() == "\n") {
				this.line++;
			}
			if(this.peek() == "$" && this.peekNext() == "{") {
				this.addToken("[interpolation]",this.source.substring(this.start + 1,this.current));
				this.advance();
				this.advance();
				this.interpolatedString(quote,depth);
				return;
			}
			this.advance();
		}
		if(this.isAtEnd()) {
			this.reporter.report({ line : this.line, offset : this.current, file : this.file},"<EOF>","Unterminated string.");
			return;
		}
		this.advance();
		var value = this.source.substring(this.start + 1,this.current - 1);
		this.addToken("[string]",value);
	}
	,interpolatedString: function(quote,depth) {
		if(quote == null) {
			quote = "\"";
		}
		++depth;
		var brackets = 1;
		if(depth > 6) {
			this.reporter.report({ line : this.line, offset : this.current, file : this.file},"","Interpolation too deep: only 5 levels allowed");
		}
		while(brackets > 0 && !this.isAtEnd()) {
			this.start = this.current;
			this.scanToken();
			if(this.peek() == "{") {
				++brackets;
			}
			if(this.peek() == "}") {
				--brackets;
			}
		}
		this.start = this.current;
		--depth;
		this.string(quote,depth);
	}
	,number: function() {
		while(this.isDigit(this.peek())) this.advance();
		if(this.peek() == "." && this.isDigit(this.peekNext())) {
			this.advance();
			while(this.isDigit(this.peek())) this.advance();
		}
		this.addToken("[number]",parseFloat(this.source.substring(this.start,this.current)));
	}
	,isAtEnd: function() {
		return this.current >= this.source.length;
	}
	,isDigit: function(c) {
		if(c >= "0") {
			return c <= "9";
		} else {
			return false;
		}
	}
	,isUcAlpha: function(c) {
		if(c >= "A") {
			return c <= "Z";
		} else {
			return false;
		}
	}
	,isAlpha: function(c) {
		if(!(c >= "a" && c <= "z" || c >= "A" && c <= "Z")) {
			return c == "_";
		} else {
			return true;
		}
	}
	,isAlphaNumeric: function(c) {
		if(!this.isAlpha(c)) {
			return this.isDigit(c);
		} else {
			return true;
		}
	}
	,match: function(expected) {
		if(this.isAtEnd()) {
			return false;
		}
		if(this.source.charAt(this.current) != expected) {
			return false;
		}
		this.current++;
		return true;
	}
	,peek: function() {
		if(this.isAtEnd()) {
			return "";
		}
		return this.source.charAt(this.current);
	}
	,peekNext: function() {
		if(this.isAtEnd()) {
			return "";
		}
		return this.source.charAt(this.current + 1);
	}
	,advance: function() {
		this.current++;
		return this.source.charAt(this.current - 1);
	}
	,addToken: function(type,literal) {
		var text = this.source.substring(this.start,this.current);
		var pos = { line : this.line, offset : this.current, file : this.file};
		this.tokens.push(new phase_Token(type,text,literal,pos));
	}
	,__class__: phase_Scanner
};
var phase_Stmt = function() { };
phase_Stmt.__name__ = true;
phase_Stmt.prototype = {
	__class__: phase_Stmt
};
var phase_Expression = function(expression) {
	this.expression = expression;
};
phase_Expression.__name__ = true;
phase_Expression.__interfaces__ = [phase_Stmt];
phase_Expression.prototype = {
	accept: function(visitor) {
		return visitor.visitExpressionStmt(this);
	}
	,__class__: phase_Expression
};
var phase_UseTarget = $hxEnums["phase.UseTarget"] = { __ename__ : true, __constructs__ : ["TargetType","TargetFunction"]
	,TargetType: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"phase.UseTarget",toString:$estr}; },$_.__params__ = ["name"],$_)
	,TargetFunction: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"phase.UseTarget",toString:$estr}; },$_.__params__ = ["name"],$_)
};
var phase_UseKind = $hxEnums["phase.UseKind"] = { __ename__ : true, __constructs__ : ["UseNormal","UseAlias","UseSub"]
	,UseNormal: {_hx_index:0,__enum__:"phase.UseKind",toString:$estr}
	,UseAlias: ($_=function(alias) { return {_hx_index:1,alias:alias,__enum__:"phase.UseKind",toString:$estr}; },$_.__params__ = ["alias"],$_)
	,UseSub: ($_=function(items) { return {_hx_index:2,items:items,__enum__:"phase.UseKind",toString:$estr}; },$_.__params__ = ["items"],$_)
};
var phase_Use = function(path,absolute,kind,annotation) {
	this.path = path;
	this.absolute = absolute;
	this.kind = kind;
	this.annotation = annotation;
};
phase_Use.__name__ = true;
phase_Use.__interfaces__ = [phase_Stmt];
phase_Use.prototype = {
	accept: function(visitor) {
		return visitor.visitUseStmt(this);
	}
	,__class__: phase_Use
};
var phase_Package = function(path,decls,annotation) {
	this.path = path;
	this.decls = decls;
	this.annotation = annotation;
};
phase_Package.__name__ = true;
phase_Package.__interfaces__ = [phase_Stmt];
phase_Package.prototype = {
	accept: function(visitor) {
		return visitor.visitPackageStmt(this);
	}
	,__class__: phase_Package
};
var phase_Var = function(name,initializer) {
	this.name = name;
	this.initializer = initializer;
};
phase_Var.__name__ = true;
phase_Var.__interfaces__ = [phase_Stmt];
phase_Var.prototype = {
	accept: function(visitor) {
		return visitor.visitVarStmt(this);
	}
	,__class__: phase_Var
};
var phase_Global = function(name) {
	this.name = name;
};
phase_Global.__name__ = true;
phase_Global.__interfaces__ = [phase_Stmt];
phase_Global.prototype = {
	accept: function(visitor) {
		return visitor.visitGlobalStmt(this);
	}
	,__class__: phase_Global
};
var phase_Throw = function(keyword,expr) {
	this.keyword = keyword;
	this.expr = expr;
};
phase_Throw.__name__ = true;
phase_Throw.__interfaces__ = [phase_Stmt];
phase_Throw.prototype = {
	accept: function(visitor) {
		return visitor.visitThrowStmt(this);
	}
	,__class__: phase_Throw
};
var phase_Try = function(body,catches) {
	this.body = body;
	this.catches = catches;
};
phase_Try.__name__ = true;
phase_Try.__interfaces__ = [phase_Stmt];
phase_Try.prototype = {
	accept: function(visitor) {
		return visitor.visitTryStmt(this);
	}
	,__class__: phase_Try
};
var phase_While = function(condition,body) {
	this.condition = condition;
	this.body = body;
};
phase_While.__name__ = true;
phase_While.__interfaces__ = [phase_Stmt];
phase_While.prototype = {
	accept: function(visitor) {
		return visitor.visitWhileStmt(this);
	}
	,__class__: phase_While
};
var phase_For = function(key,value,target,body) {
	this.key = key;
	this.value = value;
	this.target = target;
	this.body = body;
};
phase_For.__name__ = true;
phase_For.__interfaces__ = [phase_Stmt];
phase_For.prototype = {
	accept: function(visitor) {
		return visitor.visitForStmt(this);
	}
	,__class__: phase_For
};
var phase_If = function(condition,thenBranch,elseBranch) {
	this.condition = condition;
	this.thenBranch = thenBranch;
	this.elseBranch = elseBranch;
};
phase_If.__name__ = true;
phase_If.__interfaces__ = [phase_Stmt];
phase_If.prototype = {
	accept: function(visitor) {
		return visitor.visitIfStmt(this);
	}
	,__class__: phase_If
};
var phase_Switch = function(target,cases) {
	this.target = target;
	this.cases = cases;
};
phase_Switch.__name__ = true;
phase_Switch.__interfaces__ = [phase_Stmt];
phase_Switch.prototype = {
	accept: function(visitor) {
		return visitor.visitSwitchStmt(this);
	}
	,__class__: phase_Switch
};
var phase_Block = function(statements) {
	this.statements = statements;
};
phase_Block.__name__ = true;
phase_Block.__interfaces__ = [phase_Stmt];
phase_Block.prototype = {
	accept: function(visitor) {
		return visitor.visitBlockStmt(this);
	}
	,__class__: phase_Block
};
var phase_Function = function(name,params,body,ret,annotation) {
	this.name = name;
	this.params = params;
	this.body = body;
	this.ret = ret;
	this.annotation = annotation;
};
phase_Function.__name__ = true;
phase_Function.__interfaces__ = [phase_Stmt];
phase_Function.prototype = {
	accept: function(visitor) {
		return visitor.visitFunctionStmt(this);
	}
	,__class__: phase_Function
};
var phase_Return = function(keyword,value) {
	this.keyword = keyword;
	this.value = value;
};
phase_Return.__name__ = true;
phase_Return.__interfaces__ = [phase_Stmt];
phase_Return.prototype = {
	accept: function(visitor) {
		return visitor.visitReturnStmt(this);
	}
	,__class__: phase_Return
};
var phase_FieldKind = $hxEnums["phase.FieldKind"] = { __ename__ : true, __constructs__ : ["FUse","FVar","FFun"]
	,FUse: ($_=function(type) { return {_hx_index:0,type:type,__enum__:"phase.FieldKind",toString:$estr}; },$_.__params__ = ["type"],$_)
	,FVar: ($_=function(v,type) { return {_hx_index:1,v:v,type:type,__enum__:"phase.FieldKind",toString:$estr}; },$_.__params__ = ["v","type"],$_)
	,FFun: ($_=function(fun) { return {_hx_index:2,fun:fun,__enum__:"phase.FieldKind",toString:$estr}; },$_.__params__ = ["fun"],$_)
};
var phase_FieldAccess = $hxEnums["phase.FieldAccess"] = { __ename__ : true, __constructs__ : ["AStatic","APublic","APrivate","AAbstract","AConst"]
	,AStatic: {_hx_index:0,__enum__:"phase.FieldAccess",toString:$estr}
	,APublic: {_hx_index:1,__enum__:"phase.FieldAccess",toString:$estr}
	,APrivate: {_hx_index:2,__enum__:"phase.FieldAccess",toString:$estr}
	,AAbstract: {_hx_index:3,__enum__:"phase.FieldAccess",toString:$estr}
	,AConst: {_hx_index:4,__enum__:"phase.FieldAccess",toString:$estr}
};
var phase_Field = function(name,kind,access,annotation) {
	this.name = name;
	this.kind = kind;
	this.access = access;
	this.annotation = annotation;
};
phase_Field.__name__ = true;
phase_Field.__interfaces__ = [phase_Stmt];
phase_Field.prototype = {
	accept: function(visitor) {
		return visitor.visitFieldStmt(this);
	}
	,__class__: phase_Field
};
var phase_ClassKind = $hxEnums["phase.ClassKind"] = { __ename__ : true, __constructs__ : ["KindClass","KindInterface","KindTrait"]
	,KindClass: {_hx_index:0,__enum__:"phase.ClassKind",toString:$estr}
	,KindInterface: {_hx_index:1,__enum__:"phase.ClassKind",toString:$estr}
	,KindTrait: {_hx_index:2,__enum__:"phase.ClassKind",toString:$estr}
};
var phase_Class = function(name,kind,superclass,interfaces,fields,annotation) {
	this.name = name;
	this.kind = kind;
	this.superclass = superclass;
	this.interfaces = interfaces;
	this.fields = fields;
	this.annotation = annotation;
};
phase_Class.__name__ = true;
phase_Class.__interfaces__ = [phase_Stmt];
phase_Class.prototype = {
	accept: function(visitor) {
		return visitor.visitClassStmt(this);
	}
	,__class__: phase_Class
};
var phase_Token = function(type,lexeme,literal,pos) {
	this.type = type;
	this.lexeme = lexeme;
	this.literal = literal;
	this.pos = pos;
};
phase_Token.__name__ = true;
phase_Token.prototype = {
	__class__: phase_Token
};
var phase_VisualErrorReporter = function(source) {
	this.errorsReported = 0;
	this.source = source;
};
phase_VisualErrorReporter.__name__ = true;
phase_VisualErrorReporter.__interfaces__ = [phase_ErrorReporter];
phase_VisualErrorReporter.prototype = {
	hadError: function() {
		return this.errorsReported > 0;
	}
	,report: function(pos,where,message) {
		this.errorsReported++;
		var lines = this.source.split("\n");
		var limit = lines.length > 5 ? 5 : lines.length;
		var line = pos.line;
		var start = this.source.substring(0,pos.offset).split("\n")[line - 1].length - where.length;
		var end = where.length;
		var out = ["","ERROR: " + pos.file + " [line " + pos.line + " column " + start + "]:",""];
		var curLine = line - 3;
		if(curLine < 0) {
			curLine = 0;
		}
		while(true) {
			out.push(this.formatLine(curLine) + lines[curLine]);
			++curLine;
			if(!(curLine < line)) {
				break;
			}
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = start;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(" ");
		}
		var spaces = "      | " + _g.join("");
		var _g3 = [];
		var _g4 = 0;
		var _g5 = end;
		while(_g4 < _g5) {
			var i1 = _g4++;
			_g3.push("^");
		}
		var markers = spaces + _g3.join("");
		out.push(markers);
		out.push(spaces + message);
		while(true) {
			var content = lines[curLine];
			if(content == null) {
				content = "";
			}
			out.push(this.formatLine(curLine) + content);
			++curLine;
			if(!(curLine < limit)) {
				break;
			}
		}
		out.push("");
		var v = out.join("\n");
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
	}
	,formatLine: function(curLine) {
		var line = Std.string(curLine + 1);
		if(line.length == 1) {
			return "    " + line + " | ";
		}
		if(line.length == 2) {
			return "   " + line + " | ";
		}
		if(line.length == 3) {
			return "  " + line + " | ";
		}
		if(line.length == 4) {
			return " " + line + " | ";
		}
		return "" + line + " | ";
	}
	,__class__: phase_VisualErrorReporter
};
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(e1.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
				throw e1;
			}
			if(!stat.isDirectory()) {
				throw e1;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
	,__class__: sys_io_FileInput
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = new js_node_buffer_Buffer(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,__class__: sys_io_FileOutput
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__ : true, __constructs__ : ["SeekBegin","SeekCur","SeekEnd"]
	,SeekBegin: {_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
phase_NodeCompiler.extensions = ["phs","phase"];
phase_Parser.continuationTokens = [".","+","+++","|>","-","==","!=","&&","||"];
phase_PhpGenerator.typeAliases = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["String"] != null) {
		_g.setReserved("String","string");
	} else {
		_g.h["String"] = "string";
	}
	if(__map_reserved["Int"] != null) {
		_g.setReserved("Int","integer");
	} else {
		_g.h["Int"] = "integer";
	}
	if(__map_reserved["Array"] != null) {
		_g.setReserved("Array","array");
	} else {
		_g.h["Array"] = "array";
	}
	if(__map_reserved["Callable"] != null) {
		_g.setReserved("Callable","callable");
	} else {
		_g.h["Callable"] = "callable";
	}
	if(__map_reserved["Scalar"] != null) {
		_g.setReserved("Scalar","scalar");
	} else {
		_g.h["Scalar"] = "scalar";
	}
	$r = _g;
	return $r;
}(this));
phase_Scanner.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var key = "class";
		var value = "class";
		if(__map_reserved[key] != null) {
			_g.setReserved(key,value);
		} else {
			_g.h[key] = value;
		}
	}
	{
		var key1 = "interface";
		var value1 = "interface";
		if(__map_reserved[key1] != null) {
			_g.setReserved(key1,value1);
		} else {
			_g.h[key1] = value1;
		}
	}
	{
		var key2 = "trait";
		var value2 = "trait";
		if(__map_reserved[key2] != null) {
			_g.setReserved(key2,value2);
		} else {
			_g.h[key2] = value2;
		}
	}
	{
		var key3 = "enum";
		var value3 = "enum";
		if(__map_reserved[key3] != null) {
			_g.setReserved(key3,value3);
		} else {
			_g.h[key3] = value3;
		}
	}
	{
		var key4 = "extends";
		var value4 = "extends";
		if(__map_reserved[key4] != null) {
			_g.setReserved(key4,value4);
		} else {
			_g.h[key4] = value4;
		}
	}
	{
		var key5 = "implements";
		var value5 = "implements";
		if(__map_reserved[key5] != null) {
			_g.setReserved(key5,value5);
		} else {
			_g.h[key5] = value5;
		}
	}
	{
		var key6 = "enum";
		var value6 = "enum";
		if(__map_reserved[key6] != null) {
			_g.setReserved(key6,value6);
		} else {
			_g.h[key6] = value6;
		}
	}
	{
		var key7 = "static";
		var value7 = "static";
		if(__map_reserved[key7] != null) {
			_g.setReserved(key7,value7);
		} else {
			_g.h[key7] = value7;
		}
	}
	{
		var key8 = "private";
		var value8 = "private";
		if(__map_reserved[key8] != null) {
			_g.setReserved(key8,value8);
		} else {
			_g.h[key8] = value8;
		}
	}
	{
		var key9 = "public";
		var value9 = "public";
		if(__map_reserved[key9] != null) {
			_g.setReserved(key9,value9);
		} else {
			_g.h[key9] = value9;
		}
	}
	{
		var key10 = "abstract";
		var value10 = "abstract";
		if(__map_reserved[key10] != null) {
			_g.setReserved(key10,value10);
		} else {
			_g.h[key10] = value10;
		}
	}
	{
		var key11 = "const";
		var value11 = "const";
		if(__map_reserved[key11] != null) {
			_g.setReserved(key11,value11);
		} else {
			_g.h[key11] = value11;
		}
	}
	{
		var key12 = "false";
		var value12 = "false";
		if(__map_reserved[key12] != null) {
			_g.setReserved(key12,value12);
		} else {
			_g.h[key12] = value12;
		}
	}
	{
		var key13 = "true";
		var value13 = "true";
		if(__map_reserved[key13] != null) {
			_g.setReserved(key13,value13);
		} else {
			_g.h[key13] = value13;
		}
	}
	{
		var key14 = "else";
		var value14 = "else";
		if(__map_reserved[key14] != null) {
			_g.setReserved(key14,value14);
		} else {
			_g.h[key14] = value14;
		}
	}
	{
		var key15 = "function";
		var value15 = "function";
		if(__map_reserved[key15] != null) {
			_g.setReserved(key15,value15);
		} else {
			_g.h[key15] = value15;
		}
	}
	{
		var key16 = "for";
		var value16 = "for";
		if(__map_reserved[key16] != null) {
			_g.setReserved(key16,value16);
		} else {
			_g.h[key16] = value16;
		}
	}
	{
		var key17 = "if";
		var value17 = "if";
		if(__map_reserved[key17] != null) {
			_g.setReserved(key17,value17);
		} else {
			_g.h[key17] = value17;
		}
	}
	{
		var key18 = "null";
		var value18 = "null";
		if(__map_reserved[key18] != null) {
			_g.setReserved(key18,value18);
		} else {
			_g.h[key18] = value18;
		}
	}
	{
		var key19 = "return";
		var value19 = "return";
		if(__map_reserved[key19] != null) {
			_g.setReserved(key19,value19);
		} else {
			_g.h[key19] = value19;
		}
	}
	{
		var key20 = "super";
		var value20 = "super";
		if(__map_reserved[key20] != null) {
			_g.setReserved(key20,value20);
		} else {
			_g.h[key20] = value20;
		}
	}
	{
		var key21 = "this";
		var value21 = "this";
		if(__map_reserved[key21] != null) {
			_g.setReserved(key21,value21);
		} else {
			_g.h[key21] = value21;
		}
	}
	{
		var key22 = "var";
		var value22 = "var";
		if(__map_reserved[key22] != null) {
			_g.setReserved(key22,value22);
		} else {
			_g.h[key22] = value22;
		}
	}
	{
		var key23 = "global";
		var value23 = "global";
		if(__map_reserved[key23] != null) {
			_g.setReserved(key23,value23);
		} else {
			_g.h[key23] = value23;
		}
	}
	{
		var key24 = "while";
		var value24 = "while";
		if(__map_reserved[key24] != null) {
			_g.setReserved(key24,value24);
		} else {
			_g.h[key24] = value24;
		}
	}
	{
		var key25 = "use";
		var value25 = "use";
		if(__map_reserved[key25] != null) {
			_g.setReserved(key25,value25);
		} else {
			_g.h[key25] = value25;
		}
	}
	{
		var key26 = "package";
		var value26 = "package";
		if(__map_reserved[key26] != null) {
			_g.setReserved(key26,value26);
		} else {
			_g.h[key26] = value26;
		}
	}
	{
		var key27 = "as";
		var value27 = "as";
		if(__map_reserved[key27] != null) {
			_g.setReserved(key27,value27);
		} else {
			_g.h[key27] = value27;
		}
	}
	{
		var key28 = "in";
		var value28 = "in";
		if(__map_reserved[key28] != null) {
			_g.setReserved(key28,value28);
		} else {
			_g.h[key28] = value28;
		}
	}
	{
		var key29 = "is";
		var value29 = "is";
		if(__map_reserved[key29] != null) {
			_g.setReserved(key29,value29);
		} else {
			_g.h[key29] = value29;
		}
	}
	{
		var key30 = "throw";
		var value30 = "throw";
		if(__map_reserved[key30] != null) {
			_g.setReserved(key30,value30);
		} else {
			_g.h[key30] = value30;
		}
	}
	{
		var key31 = "try";
		var value31 = "try";
		if(__map_reserved[key31] != null) {
			_g.setReserved(key31,value31);
		} else {
			_g.h[key31] = value31;
		}
	}
	{
		var key32 = "catch";
		var value32 = "catch";
		if(__map_reserved[key32] != null) {
			_g.setReserved(key32,value32);
		} else {
			_g.h[key32] = value32;
		}
	}
	{
		var key33 = "switch";
		var value33 = "switch";
		if(__map_reserved[key33] != null) {
			_g.setReserved(key33,value33);
		} else {
			_g.h[key33] = value33;
		}
	}
	{
		var key34 = "case";
		var value34 = "case";
		if(__map_reserved[key34] != null) {
			_g.setReserved(key34,value34);
		} else {
			_g.h[key34] = value34;
		}
	}
	{
		var key35 = "default";
		var value35 = "default";
		if(__map_reserved[key35] != null) {
			_g.setReserved(key35,value35);
		} else {
			_g.h[key35] = value35;
		}
	}
	$r = _g;
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
